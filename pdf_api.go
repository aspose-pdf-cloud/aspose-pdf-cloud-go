/*
*
* Copyright (c) 2023 Aspose.PDF Cloud
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
* The above copyright notice and this permission notice shall be included in all
* copies or substantial portions of the Software.
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*
*/

package asposepdfcloud

import (
	"io/ioutil"
	_url "net/url"
	"net/http"
	"strings"
	"os"
	"fmt"
)

type PdfApiService service

/* Create Instance of PdfApiService
 @param appSid string Application SID
 @param appKey string Application Key
 @param basePath string Base service path. Set "" for default
 @return *PdfApiService */
 func NewPdfApiService(appSid string, appKey string, basePath string) *PdfApiService {
	config := NewConfiguration(appSid, appKey, basePath)
	client := NewAPIClient(config)
	return client.PdfApi
}


/* PdfApiService Copy file
 @param srcPath Source file path e.g. &#39;/folder/file.ext&#39;
 @param destPath Destination file path
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "srcStorageName" (string) Source storage name
     @param "destStorageName" (string) Destination storage name
     @param "versionId" (string) File version ID to copy
 @return */
func (a *PdfApiService) CopyFile(srcPath string, destPath string, localVarOptionals map[string]interface{}) ( *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/storage/file/copy/{srcPath}"
	localVarPath = strings.Replace(localVarPath, "{"+"srcPath"+"}", fmt.Sprintf("%v", srcPath), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["srcStorageName"], "string", "srcStorageName"); err != nil {
		return nil, err
	}
	if err := typeCheckParameter(localVarOptionals["destStorageName"], "string", "destStorageName"); err != nil {
		return nil, err
	}
	if err := typeCheckParameter(localVarOptionals["versionId"], "string", "versionId"); err != nil {
		return nil, err
	}

	localVarQueryParams.Add("destPath", parameterToString(destPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["srcStorageName"].(string); localVarOk {
		localVarQueryParams.Add("srcStorageName", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["destStorageName"].(string); localVarOk {
		localVarQueryParams.Add("destStorageName", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["versionId"].(string); localVarOk {
		localVarQueryParams.Add("versionId", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	return localVarHttpResponse, err
}

/* PdfApiService Copy folder
 @param srcPath Source folder path e.g. &#39;/src&#39;
 @param destPath Destination folder path e.g. &#39;/dst&#39;
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "srcStorageName" (string) Source storage name
     @param "destStorageName" (string) Destination storage name
 @return */
func (a *PdfApiService) CopyFolder(srcPath string, destPath string, localVarOptionals map[string]interface{}) ( *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/storage/folder/copy/{srcPath}"
	localVarPath = strings.Replace(localVarPath, "{"+"srcPath"+"}", fmt.Sprintf("%v", srcPath), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["srcStorageName"], "string", "srcStorageName"); err != nil {
		return nil, err
	}
	if err := typeCheckParameter(localVarOptionals["destStorageName"], "string", "destStorageName"); err != nil {
		return nil, err
	}

	localVarQueryParams.Add("destPath", parameterToString(destPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["srcStorageName"].(string); localVarOk {
		localVarQueryParams.Add("srcStorageName", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["destStorageName"].(string); localVarOk {
		localVarQueryParams.Add("destStorageName", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	return localVarHttpResponse, err
}

/* PdfApiService Create the folder
 @param path Folder path to create e.g. &#39;folder_1/folder_2/&#39;
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storageName" (string) Storage name
 @return */
func (a *PdfApiService) CreateFolder(path string, localVarOptionals map[string]interface{}) ( *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/storage/folder/{path}"
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", fmt.Sprintf("%v", path), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storageName"], "string", "storageName"); err != nil {
		return nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storageName"].(string); localVarOk {
		localVarQueryParams.Add("storageName", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	return localVarHttpResponse, err
}

/* PdfApiService Delete document annotation by ID
 @param name The document name.
 @param annotationId The annotation ID.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) DeleteAnnotation(name string, annotationId string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/{annotationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Delete document bookmark by ID.
 @param name The document name.
 @param bookmarkPath The bookmark path.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
 @return AsposeResponse*/
func (a *PdfApiService) DeleteBookmark(name string, bookmarkPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/bookmarks/bookmark/{bookmarkPath}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"bookmarkPath"+"}", fmt.Sprintf("%v", bookmarkPath), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Delete all annotations from the document
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) DeleteDocumentAnnotations(name string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Delete all document bookmarks.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
 @return AsposeResponse*/
func (a *PdfApiService) DeleteDocumentBookmarks(name string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/bookmarks/tree"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Delete all link annotations from the document
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) DeleteDocumentLinkAnnotations(name string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/links"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Delete all stamps from the document
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) DeleteDocumentStamps(name string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/stamps"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Delete all tables from the document
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) DeleteDocumentTables(name string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/tables"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Delete document field by name.
 @param name The document name.
 @param fieldName The field name/
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) DeleteField(name string, fieldName string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/fields/{fieldName}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fieldName"+"}", fmt.Sprintf("%v", fieldName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Delete file
 @param path File path e.g. &#39;/folder/file.ext&#39;
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storageName" (string) Storage name
     @param "versionId" (string) File version ID to delete
 @return */
func (a *PdfApiService) DeleteFile(path string, localVarOptionals map[string]interface{}) ( *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/storage/file/{path}"
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", fmt.Sprintf("%v", path), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storageName"], "string", "storageName"); err != nil {
		return nil, err
	}
	if err := typeCheckParameter(localVarOptionals["versionId"], "string", "versionId"); err != nil {
		return nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storageName"].(string); localVarOk {
		localVarQueryParams.Add("storageName", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["versionId"].(string); localVarOk {
		localVarQueryParams.Add("versionId", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	return localVarHttpResponse, err
}

/* PdfApiService Delete folder
 @param path Folder path e.g. &#39;/folder&#39;
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storageName" (string) Storage name
     @param "recursive" (bool) Enable to delete folders, subfolders and files
 @return */
func (a *PdfApiService) DeleteFolder(path string, localVarOptionals map[string]interface{}) ( *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/storage/folder/{path}"
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", fmt.Sprintf("%v", path), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storageName"], "string", "storageName"); err != nil {
		return nil, err
	}
	if err := typeCheckParameter(localVarOptionals["recursive"], "bool", "recursive"); err != nil {
		return nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storageName"].(string); localVarOk {
		localVarQueryParams.Add("storageName", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["recursive"].(bool); localVarOk {
		localVarQueryParams.Add("recursive", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	return localVarHttpResponse, err
}

/* PdfApiService Delete image from document page.
 @param name The document name.
 @param imageId Image ID.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) DeleteImage(name string, imageId string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/images/{imageId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageId"+"}", fmt.Sprintf("%v", imageId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Delete document page link annotation by ID
 @param name The document name.
 @param linkId The link ID.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) DeleteLinkAnnotation(name string, linkId string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/links/{linkId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"linkId"+"}", fmt.Sprintf("%v", linkId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Delete document page by its number.
 @param name The document name.
 @param pageNumber The page number.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) DeletePage(name string, pageNumber int32, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Delete all annotations from the page
 @param name The document name.
 @param pageNumber The page number.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) DeletePageAnnotations(name string, pageNumber int32, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/annotations"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Delete all link annotations from the page
 @param name The document name.
 @param pageNumber The page number.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) DeletePageLinkAnnotations(name string, pageNumber int32, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/links"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Delete all stamps from the page
 @param name The document name.
 @param pageNumber The page number.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) DeletePageStamps(name string, pageNumber int32, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/stamps"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Delete all tables from the page
 @param name The document name.
 @param pageNumber The page number.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) DeletePageTables(name string, pageNumber int32, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/tables"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Delete custom document properties.
 @param name 
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) 
     @param "folder" (string) 
 @return AsposeResponse*/
func (a *PdfApiService) DeleteProperties(name string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/documentproperties"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Delete document property.
 @param name 
 @param propertyName 
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) 
     @param "folder" (string) 
 @return AsposeResponse*/
func (a *PdfApiService) DeleteProperty(name string, propertyName string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/documentproperties/{propertyName}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"propertyName"+"}", fmt.Sprintf("%v", propertyName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Delete document stamp by ID
 @param name The document name.
 @param stampId The stamp ID.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) DeleteStamp(name string, stampId string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/stamps/{stampId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"stampId"+"}", fmt.Sprintf("%v", stampId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Delete document table by ID
 @param name The document name.
 @param tableId The table ID.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) DeleteTable(name string, tableId string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/tables/{tableId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tableId"+"}", fmt.Sprintf("%v", tableId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Download file
 @param path File path e.g. &#39;/folder/file.ext&#39;
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storageName" (string) Storage name
     @param "versionId" (string) File version ID to download
 @return []byte*/
func (a *PdfApiService) DownloadFile(path string, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/storage/file/{path}"
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", fmt.Sprintf("%v", path), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storageName"], "string", "storageName"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["versionId"], "string", "versionId"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storageName"].(string); localVarOk {
		localVarQueryParams.Add("storageName", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["versionId"].(string); localVarOk {
		localVarQueryParams.Add("versionId", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document bookmark.
 @param name The document name.
 @param bookmarkPath The bookmark path.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
 @return BookmarkResponse*/
func (a *PdfApiService) GetBookmark(name string, bookmarkPath string, localVarOptionals map[string]interface{}) (BookmarkResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload BookmarkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/bookmarks/bookmark/{bookmarkPath}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"bookmarkPath"+"}", fmt.Sprintf("%v", bookmarkPath), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document bookmarks node list.
 @param name The document name.
 @param bookmarkPath The bookmark path.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
 @return BookmarksResponse*/
func (a *PdfApiService) GetBookmarks(name string, bookmarkPath string, localVarOptionals map[string]interface{}) (BookmarksResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload BookmarksResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/bookmarks/list/{bookmarkPath}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"bookmarkPath"+"}", fmt.Sprintf("%v", bookmarkPath), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page caret annotation by ID.
 @param name The document name.
 @param annotationId The annotation ID.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return CaretAnnotationResponse*/
func (a *PdfApiService) GetCaretAnnotation(name string, annotationId string, localVarOptionals map[string]interface{}) (CaretAnnotationResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload CaretAnnotationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/caret/{annotationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document checkbox field by name.
 @param name The document name.
 @param fieldName The field name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return CheckBoxFieldResponse*/
func (a *PdfApiService) GetCheckBoxField(name string, fieldName string, localVarOptionals map[string]interface{}) (CheckBoxFieldResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload CheckBoxFieldResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/fields/checkbox/{fieldName}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fieldName"+"}", fmt.Sprintf("%v", fieldName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page circle annotation by ID.
 @param name The document name.
 @param annotationId The annotation ID.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return CircleAnnotationResponse*/
func (a *PdfApiService) GetCircleAnnotation(name string, annotationId string, localVarOptionals map[string]interface{}) (CircleAnnotationResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload CircleAnnotationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/circle/{annotationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document combobox field by name.
 @param name The document name.
 @param fieldName The field name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return ComboBoxFieldResponse*/
func (a *PdfApiService) GetComboBoxField(name string, fieldName string, localVarOptionals map[string]interface{}) (ComboBoxFieldResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload ComboBoxFieldResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/fields/combobox/{fieldName}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fieldName"+"}", fmt.Sprintf("%v", fieldName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Get disc usage
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storageName" (string) Storage name
 @return DiscUsage*/
func (a *PdfApiService) GetDiscUsage(localVarOptionals map[string]interface{}) (DiscUsage,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload DiscUsage
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/storage/disc"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storageName"], "string", "storageName"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storageName"].(string); localVarOk {
		localVarQueryParams.Add("storageName", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read common document info.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return DocumentResponse*/
func (a *PdfApiService) GetDocument(name string, localVarOptionals map[string]interface{}) (DocumentResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload DocumentResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page annotations. Returns only FreeTextAnnotations, TextAnnotations, other annotations will implemented next releases.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AnnotationsInfoResponse*/
func (a *PdfApiService) GetDocumentAnnotations(name string, localVarOptionals map[string]interface{}) (AnnotationsInfoResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AnnotationsInfoResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document attachment info by its index.
 @param name The document name.
 @param attachmentIndex The attachment index.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AttachmentResponse*/
func (a *PdfApiService) GetDocumentAttachmentByIndex(name string, attachmentIndex int32, localVarOptionals map[string]interface{}) (AttachmentResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AttachmentResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/attachments/{attachmentIndex}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachmentIndex"+"}", fmt.Sprintf("%v", attachmentIndex), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document attachments info.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AttachmentsResponse*/
func (a *PdfApiService) GetDocumentAttachments(name string, localVarOptionals map[string]interface{}) (AttachmentsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AttachmentsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document bookmarks tree.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
 @return BookmarksResponse*/
func (a *PdfApiService) GetDocumentBookmarks(name string, localVarOptionals map[string]interface{}) (BookmarksResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload BookmarksResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/bookmarks/tree"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document caret annotations.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return CaretAnnotationsResponse*/
func (a *PdfApiService) GetDocumentCaretAnnotations(name string, localVarOptionals map[string]interface{}) (CaretAnnotationsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload CaretAnnotationsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/caret"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document checkbox fields.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return CheckBoxFieldsResponse*/
func (a *PdfApiService) GetDocumentCheckBoxFields(name string, localVarOptionals map[string]interface{}) (CheckBoxFieldsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload CheckBoxFieldsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/fields/checkbox"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document circle annotations.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return CircleAnnotationsResponse*/
func (a *PdfApiService) GetDocumentCircleAnnotations(name string, localVarOptionals map[string]interface{}) (CircleAnnotationsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload CircleAnnotationsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/circle"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document combobox fields.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return ComboBoxFieldsResponse*/
func (a *PdfApiService) GetDocumentComboBoxFields(name string, localVarOptionals map[string]interface{}) (ComboBoxFieldsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload ComboBoxFieldsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/fields/combobox"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document display properties.
 @param name 
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) 
     @param "folder" (string) 
 @return DisplayPropertiesResponse*/
func (a *PdfApiService) GetDocumentDisplayProperties(name string, localVarOptionals map[string]interface{}) (DisplayPropertiesResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload DisplayPropertiesResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/displayproperties"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document FileAttachment annotations.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return FileAttachmentAnnotationsResponse*/
func (a *PdfApiService) GetDocumentFileAttachmentAnnotations(name string, localVarOptionals map[string]interface{}) (FileAttachmentAnnotationsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload FileAttachmentAnnotationsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/fileattachment"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document free text annotations.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return FreeTextAnnotationsResponse*/
func (a *PdfApiService) GetDocumentFreeTextAnnotations(name string, localVarOptionals map[string]interface{}) (FreeTextAnnotationsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload FreeTextAnnotationsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/freetext"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document highlight annotations.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return HighlightAnnotationsResponse*/
func (a *PdfApiService) GetDocumentHighlightAnnotations(name string, localVarOptionals map[string]interface{}) (HighlightAnnotationsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload HighlightAnnotationsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/highlight"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document ink annotations.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return InkAnnotationsResponse*/
func (a *PdfApiService) GetDocumentInkAnnotations(name string, localVarOptionals map[string]interface{}) (InkAnnotationsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload InkAnnotationsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/ink"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document line annotations.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return LineAnnotationsResponse*/
func (a *PdfApiService) GetDocumentLineAnnotations(name string, localVarOptionals map[string]interface{}) (LineAnnotationsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload LineAnnotationsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/line"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document listbox fields.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return ListBoxFieldsResponse*/
func (a *PdfApiService) GetDocumentListBoxFields(name string, localVarOptionals map[string]interface{}) (ListBoxFieldsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload ListBoxFieldsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/fields/listbox"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document movie annotations.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return MovieAnnotationsResponse*/
func (a *PdfApiService) GetDocumentMovieAnnotations(name string, localVarOptionals map[string]interface{}) (MovieAnnotationsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload MovieAnnotationsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/movie"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document polyline annotations.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return PolyLineAnnotationsResponse*/
func (a *PdfApiService) GetDocumentPolyLineAnnotations(name string, localVarOptionals map[string]interface{}) (PolyLineAnnotationsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload PolyLineAnnotationsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/polyline"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document polygon annotations.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return PolygonAnnotationsResponse*/
func (a *PdfApiService) GetDocumentPolygonAnnotations(name string, localVarOptionals map[string]interface{}) (PolygonAnnotationsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload PolygonAnnotationsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/polygon"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document popup annotations.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return PopupAnnotationsResponse*/
func (a *PdfApiService) GetDocumentPopupAnnotations(name string, localVarOptionals map[string]interface{}) (PopupAnnotationsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload PopupAnnotationsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/popup"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document popup annotations by parent id.
 @param name The document name.
 @param annotationId The parent annotation ID.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return PopupAnnotationsResponse*/
func (a *PdfApiService) GetDocumentPopupAnnotationsByParent(name string, annotationId string, localVarOptionals map[string]interface{}) (PopupAnnotationsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload PopupAnnotationsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/{annotationId}/popup"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document properties.
 @param name 
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) 
     @param "folder" (string) 
 @return DocumentPropertiesResponse*/
func (a *PdfApiService) GetDocumentProperties(name string, localVarOptionals map[string]interface{}) (DocumentPropertiesResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload DocumentPropertiesResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/documentproperties"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document property by name.
 @param name 
 @param propertyName 
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) 
     @param "folder" (string) 
 @return DocumentPropertyResponse*/
func (a *PdfApiService) GetDocumentProperty(name string, propertyName string, localVarOptionals map[string]interface{}) (DocumentPropertyResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload DocumentPropertyResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/documentproperties/{propertyName}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"propertyName"+"}", fmt.Sprintf("%v", propertyName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document radiobutton fields.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return RadioButtonFieldsResponse*/
func (a *PdfApiService) GetDocumentRadioButtonFields(name string, localVarOptionals map[string]interface{}) (RadioButtonFieldsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload RadioButtonFieldsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/fields/radiobutton"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document redaction annotations.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return RedactionAnnotationsResponse*/
func (a *PdfApiService) GetDocumentRedactionAnnotations(name string, localVarOptionals map[string]interface{}) (RedactionAnnotationsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload RedactionAnnotationsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/redaction"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document screen annotations.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return ScreenAnnotationsResponse*/
func (a *PdfApiService) GetDocumentScreenAnnotations(name string, localVarOptionals map[string]interface{}) (ScreenAnnotationsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload ScreenAnnotationsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/screen"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document signature fields.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return SignatureFieldsResponse*/
func (a *PdfApiService) GetDocumentSignatureFields(name string, localVarOptionals map[string]interface{}) (SignatureFieldsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload SignatureFieldsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/fields/signature"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document sound annotations.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return SoundAnnotationsResponse*/
func (a *PdfApiService) GetDocumentSoundAnnotations(name string, localVarOptionals map[string]interface{}) (SoundAnnotationsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload SoundAnnotationsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/sound"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document square annotations.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return SquareAnnotationsResponse*/
func (a *PdfApiService) GetDocumentSquareAnnotations(name string, localVarOptionals map[string]interface{}) (SquareAnnotationsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload SquareAnnotationsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/square"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document squiggly annotations.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return SquigglyAnnotationsResponse*/
func (a *PdfApiService) GetDocumentSquigglyAnnotations(name string, localVarOptionals map[string]interface{}) (SquigglyAnnotationsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload SquigglyAnnotationsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/squiggly"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document stamp annotations.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return StampAnnotationsResponse*/
func (a *PdfApiService) GetDocumentStampAnnotations(name string, localVarOptionals map[string]interface{}) (StampAnnotationsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload StampAnnotationsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/stamp"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document stamps.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return StampsInfoResponse*/
func (a *PdfApiService) GetDocumentStamps(name string, localVarOptionals map[string]interface{}) (StampsInfoResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload StampsInfoResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/stamps"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document StrikeOut annotations.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return StrikeOutAnnotationsResponse*/
func (a *PdfApiService) GetDocumentStrikeOutAnnotations(name string, localVarOptionals map[string]interface{}) (StrikeOutAnnotationsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload StrikeOutAnnotationsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/strikeout"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document tables.
 @param name 
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) 
     @param "folder" (string) 
 @return TablesRecognizedResponse*/
func (a *PdfApiService) GetDocumentTables(name string, localVarOptionals map[string]interface{}) (TablesRecognizedResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload TablesRecognizedResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/tables"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document text annotations.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return TextAnnotationsResponse*/
func (a *PdfApiService) GetDocumentTextAnnotations(name string, localVarOptionals map[string]interface{}) (TextAnnotationsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload TextAnnotationsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/text"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document text box fields.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return TextBoxFieldsResponse*/
func (a *PdfApiService) GetDocumentTextBoxFields(name string, localVarOptionals map[string]interface{}) (TextBoxFieldsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload TextBoxFieldsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/fields/textbox"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document underline annotations.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return UnderlineAnnotationsResponse*/
func (a *PdfApiService) GetDocumentUnderlineAnnotations(name string, localVarOptionals map[string]interface{}) (UnderlineAnnotationsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload UnderlineAnnotationsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/underline"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Download document attachment content by its index.
 @param name The document name.
 @param attachmentIndex The attachment index.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return []byte*/
func (a *PdfApiService) GetDownloadDocumentAttachmentByIndex(name string, attachmentIndex int32, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/attachments/{attachmentIndex}/download"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachmentIndex"+"}", fmt.Sprintf("%v", attachmentIndex), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Convert EPUB file (located on storage) to PDF format and return resulting file in response. 
 @param srcPath Full source filename (ex. /folder1/folder2/template.epub)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
 @return []byte*/
func (a *PdfApiService) GetEpubInStorageToPdf(srcPath string, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/create/epub"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("srcPath", parameterToString(srcPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Export fields from from PDF in storage to FDF file.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return []byte*/
func (a *PdfApiService) GetExportFieldsFromPdfToFdfInStorage(name string, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/export/fdf"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Export fields from from PDF in storage to XFDF file.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return []byte*/
func (a *PdfApiService) GetExportFieldsFromPdfToXfdfInStorage(name string, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/export/xfdf"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Export fields from from PDF in storage to XML file.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return []byte*/
func (a *PdfApiService) GetExportFieldsFromPdfToXmlInStorage(name string, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/export/xml"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Get document field by name.
 @param name The document name.
 @param fieldName The field name (name should be encoded).
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return FieldResponse*/
func (a *PdfApiService) GetField(name string, fieldName string, localVarOptionals map[string]interface{}) (FieldResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload FieldResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/fields/{fieldName}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fieldName"+"}", fmt.Sprintf("%v", fieldName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Get document fields.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return FieldsResponse*/
func (a *PdfApiService) GetFields(name string, localVarOptionals map[string]interface{}) (FieldsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload FieldsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/fields"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page FileAttachment annotation by ID.
 @param name The document name.
 @param annotationId The annotation ID.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return FileAttachmentAnnotationResponse*/
func (a *PdfApiService) GetFileAttachmentAnnotation(name string, annotationId string, localVarOptionals map[string]interface{}) (FileAttachmentAnnotationResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload FileAttachmentAnnotationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/fileattachment/{annotationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page FileAttachment annotation by ID.
 @param name The document name.
 @param annotationId The annotation ID.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return []byte*/
func (a *PdfApiService) GetFileAttachmentAnnotationData(name string, annotationId string, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/fileattachment/{annotationId}/data"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Get file versions
 @param path File path e.g. &#39;/file.ext&#39;
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storageName" (string) Storage name
 @return FileVersions*/
func (a *PdfApiService) GetFileVersions(path string, localVarOptionals map[string]interface{}) (FileVersions,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload FileVersions
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/storage/version/{path}"
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", fmt.Sprintf("%v", path), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storageName"], "string", "storageName"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storageName"].(string); localVarOk {
		localVarQueryParams.Add("storageName", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Get all files and folders within a folder
 @param path Folder path e.g. &#39;/folder&#39;
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storageName" (string) Storage name
 @return FilesList*/
func (a *PdfApiService) GetFilesList(path string, localVarOptionals map[string]interface{}) (FilesList,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload FilesList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/storage/folder/{path}"
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", fmt.Sprintf("%v", path), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storageName"], "string", "storageName"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storageName"].(string); localVarOk {
		localVarQueryParams.Add("storageName", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page free text annotation by ID.
 @param name The document name.
 @param annotationId The annotation ID.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return FreeTextAnnotationResponse*/
func (a *PdfApiService) GetFreeTextAnnotation(name string, annotationId string, localVarOptionals map[string]interface{}) (FreeTextAnnotationResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload FreeTextAnnotationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/freetext/{annotationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page highlight annotation by ID.
 @param name The document name.
 @param annotationId The annotation ID.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return HighlightAnnotationResponse*/
func (a *PdfApiService) GetHighlightAnnotation(name string, annotationId string, localVarOptionals map[string]interface{}) (HighlightAnnotationResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload HighlightAnnotationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/highlight/{annotationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Convert HTML file (located on storage) to PDF format and return resulting file in response. 
 @param srcPath Full source filename (ex. /folder1/folder2/template.zip)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "htmlFileName" (string) Name of HTML file in ZIP.
     @param "height" (float64) Page height
     @param "width" (float64) Page width
     @param "isLandscape" (bool) Is page landscaped
     @param "marginLeft" (float64) Page margin left
     @param "marginBottom" (float64) Page margin bottom
     @param "marginRight" (float64) Page margin right
     @param "marginTop" (float64) Page margin top
     @param "storage" (string) The document storage.
 @return []byte*/
func (a *PdfApiService) GetHtmlInStorageToPdf(srcPath string, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/create/html"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["htmlFileName"], "string", "htmlFileName"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["height"], "float64", "height"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["width"], "float64", "width"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["isLandscape"], "bool", "isLandscape"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["marginLeft"], "float64", "marginLeft"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["marginBottom"], "float64", "marginBottom"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["marginRight"], "float64", "marginRight"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["marginTop"], "float64", "marginTop"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("srcPath", parameterToString(srcPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["htmlFileName"].(string); localVarOk {
		localVarQueryParams.Add("htmlFileName", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["height"].(float64); localVarOk {
		localVarQueryParams.Add("height", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["width"].(float64); localVarOk {
		localVarQueryParams.Add("width", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["isLandscape"].(bool); localVarOk {
		localVarQueryParams.Add("isLandscape", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["marginLeft"].(float64); localVarOk {
		localVarQueryParams.Add("marginLeft", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["marginBottom"].(float64); localVarOk {
		localVarQueryParams.Add("marginBottom", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["marginRight"].(float64); localVarOk {
		localVarQueryParams.Add("marginRight", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["marginTop"].(float64); localVarOk {
		localVarQueryParams.Add("marginTop", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document image by ID.
 @param name The document name.
 @param imageId Image ID.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return ImageResponse*/
func (a *PdfApiService) GetImage(name string, imageId string, localVarOptionals map[string]interface{}) (ImageResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload ImageResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/images/{imageId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageId"+"}", fmt.Sprintf("%v", imageId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Extract document image in GIF format
 @param name The document name.
 @param imageId Image ID.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "width" (int32) The converted image width.
     @param "height" (int32) The converted image height.
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return []byte*/
func (a *PdfApiService) GetImageExtractAsGif(name string, imageId string, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/images/{imageId}/extract/gif"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageId"+"}", fmt.Sprintf("%v", imageId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["width"], "int32", "width"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["height"], "int32", "height"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["width"].(int32); localVarOk {
		localVarQueryParams.Add("width", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["height"].(int32); localVarOk {
		localVarQueryParams.Add("height", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Extract document image in JPEG format
 @param name The document name.
 @param imageId Image ID.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "width" (int32) The converted image width.
     @param "height" (int32) The converted image height.
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return []byte*/
func (a *PdfApiService) GetImageExtractAsJpeg(name string, imageId string, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/images/{imageId}/extract/jpeg"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageId"+"}", fmt.Sprintf("%v", imageId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["width"], "int32", "width"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["height"], "int32", "height"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["width"].(int32); localVarOk {
		localVarQueryParams.Add("width", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["height"].(int32); localVarOk {
		localVarQueryParams.Add("height", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Extract document image in PNG format
 @param name The document name.
 @param imageId Image ID.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "width" (int32) The converted image width.
     @param "height" (int32) The converted image height.
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return []byte*/
func (a *PdfApiService) GetImageExtractAsPng(name string, imageId string, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/images/{imageId}/extract/png"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageId"+"}", fmt.Sprintf("%v", imageId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["width"], "int32", "width"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["height"], "int32", "height"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["width"].(int32); localVarOk {
		localVarQueryParams.Add("width", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["height"].(int32); localVarOk {
		localVarQueryParams.Add("height", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Extract document image in TIFF format
 @param name The document name.
 @param imageId Image ID.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "width" (int32) The converted image width.
     @param "height" (int32) The converted image height.
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return []byte*/
func (a *PdfApiService) GetImageExtractAsTiff(name string, imageId string, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/images/{imageId}/extract/tiff"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageId"+"}", fmt.Sprintf("%v", imageId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["width"], "int32", "width"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["height"], "int32", "height"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["width"].(int32); localVarOk {
		localVarQueryParams.Add("width", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["height"].(int32); localVarOk {
		localVarQueryParams.Add("height", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document images.
 @param name The document name.
 @param pageNumber The page number.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return ImagesResponse*/
func (a *PdfApiService) GetImages(name string, pageNumber int32, localVarOptionals map[string]interface{}) (ImagesResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload ImagesResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/images"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Update fields from FDF file in storage.
 @param name The document name.
 @param fdfFilePath The Fdf file path.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return []byte*/
func (a *PdfApiService) GetImportFieldsFromFdfInStorage(name string, fdfFilePath string, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/import/fdf"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("fdfFilePath", parameterToString(fdfFilePath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Update fields from XFDF file in storage.
 @param name The document name.
 @param xfdfFilePath The XFDF file path.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return []byte*/
func (a *PdfApiService) GetImportFieldsFromXfdfInStorage(name string, xfdfFilePath string, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/import/xfdf"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("xfdfFilePath", parameterToString(xfdfFilePath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Import from XML file (located on storage) to PDF format and return resulting file in response. 
 @param name The document name.
 @param xmlFilePath Full source filename (ex. /folder1/folder2/template.xml)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return []byte*/
func (a *PdfApiService) GetImportFieldsFromXmlInStorage(name string, xmlFilePath string, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/import/xml"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("xmlFilePath", parameterToString(xmlFilePath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page ink annotation by ID.
 @param name The document name.
 @param annotationId The annotation ID.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return InkAnnotationResponse*/
func (a *PdfApiService) GetInkAnnotation(name string, annotationId string, localVarOptionals map[string]interface{}) (InkAnnotationResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload InkAnnotationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/ink/{annotationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page line annotation by ID.
 @param name The document name.
 @param annotationId The annotation ID.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return LineAnnotationResponse*/
func (a *PdfApiService) GetLineAnnotation(name string, annotationId string, localVarOptionals map[string]interface{}) (LineAnnotationResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload LineAnnotationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/line/{annotationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document link annotation by ID.
 @param name The document name.
 @param linkId The link ID.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return LinkAnnotationResponse*/
func (a *PdfApiService) GetLinkAnnotation(name string, linkId string, localVarOptionals map[string]interface{}) (LinkAnnotationResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload LinkAnnotationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/links/{linkId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"linkId"+"}", fmt.Sprintf("%v", linkId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document listbox field by name.
 @param name The document name.
 @param fieldName The field name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return ListBoxFieldResponse*/
func (a *PdfApiService) GetListBoxField(name string, fieldName string, localVarOptionals map[string]interface{}) (ListBoxFieldResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload ListBoxFieldResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/fields/listbox/{fieldName}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fieldName"+"}", fmt.Sprintf("%v", fieldName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Convert MD file (located on storage) to PDF format and return resulting file in response. 
 @param srcPath Full source filename (ex. /folder1/folder2/template.md)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
 @return []byte*/
func (a *PdfApiService) GetMarkdownInStorageToPdf(srcPath string, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/create/markdown"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("srcPath", parameterToString(srcPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Convert MHT file (located on storage) to PDF format and return resulting file in response. 
 @param srcPath Full source filename (ex. /folder1/folder2/template.mht)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
 @return []byte*/
func (a *PdfApiService) GetMhtInStorageToPdf(srcPath string, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/create/mht"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("srcPath", parameterToString(srcPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page movie annotation by ID.
 @param name The document name.
 @param annotationId The annotation ID.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return MovieAnnotationResponse*/
func (a *PdfApiService) GetMovieAnnotation(name string, annotationId string, localVarOptionals map[string]interface{}) (MovieAnnotationResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload MovieAnnotationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/movie/{annotationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page info.
 @param name The document name.
 @param pageNumber The page number.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return DocumentPageResponse*/
func (a *PdfApiService) GetPage(name string, pageNumber int32, localVarOptionals map[string]interface{}) (DocumentPageResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload DocumentPageResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page annotations. Returns only FreeTextAnnotations, TextAnnotations, other annotations will implemented next releases.
 @param name The document name.
 @param pageNumber The page number.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AnnotationsInfoResponse*/
func (a *PdfApiService) GetPageAnnotations(name string, pageNumber int32, localVarOptionals map[string]interface{}) (AnnotationsInfoResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AnnotationsInfoResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/annotations"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page caret annotations.
 @param name The document name.
 @param pageNumber The page number.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return CaretAnnotationsResponse*/
func (a *PdfApiService) GetPageCaretAnnotations(name string, pageNumber int32, localVarOptionals map[string]interface{}) (CaretAnnotationsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload CaretAnnotationsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/annotations/caret"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page checkbox fields.
 @param name The document name.
 @param pageNumber The page number.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return CheckBoxFieldsResponse*/
func (a *PdfApiService) GetPageCheckBoxFields(name string, pageNumber int32, localVarOptionals map[string]interface{}) (CheckBoxFieldsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload CheckBoxFieldsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/page/{pageNumber}/fields/checkbox"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page circle annotations.
 @param name The document name.
 @param pageNumber The page number.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return CircleAnnotationsResponse*/
func (a *PdfApiService) GetPageCircleAnnotations(name string, pageNumber int32, localVarOptionals map[string]interface{}) (CircleAnnotationsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload CircleAnnotationsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/annotations/circle"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page combobox fields.
 @param name The document name.
 @param pageNumber The page number.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return ComboBoxFieldsResponse*/
func (a *PdfApiService) GetPageComboBoxFields(name string, pageNumber int32, localVarOptionals map[string]interface{}) (ComboBoxFieldsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload ComboBoxFieldsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/page/{pageNumber}/fields/combobox"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Convert document page to Bmp image and return resulting file in response.
 @param name The document name.
 @param pageNumber The page number.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "width" (int32) The converted image width.
     @param "height" (int32) The converted image height.
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
     @param "password" (string) The password (Base64).
 @return []byte*/
func (a *PdfApiService) GetPageConvertToBmp(name string, pageNumber int32, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/convert/bmp"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["width"], "int32", "width"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["height"], "int32", "height"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["password"], "string", "password"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["width"].(int32); localVarOk {
		localVarQueryParams.Add("width", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["height"].(int32); localVarOk {
		localVarQueryParams.Add("height", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["password"].(string); localVarOk {
		localVarQueryParams.Add("password", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Convert document page to Emf image and return resulting file in response.
 @param name The document name.
 @param pageNumber The page number.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "width" (int32) The converted image width.
     @param "height" (int32) The converted image height.
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
     @param "password" (string) The password (Base64).
 @return []byte*/
func (a *PdfApiService) GetPageConvertToEmf(name string, pageNumber int32, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/convert/emf"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["width"], "int32", "width"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["height"], "int32", "height"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["password"], "string", "password"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["width"].(int32); localVarOk {
		localVarQueryParams.Add("width", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["height"].(int32); localVarOk {
		localVarQueryParams.Add("height", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["password"].(string); localVarOk {
		localVarQueryParams.Add("password", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Convert document page to Gif image and return resulting file in response.
 @param name The document name.
 @param pageNumber The page number.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "width" (int32) The converted image width.
     @param "height" (int32) The converted image height.
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
     @param "password" (string) The password (Base64).
 @return []byte*/
func (a *PdfApiService) GetPageConvertToGif(name string, pageNumber int32, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/convert/gif"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["width"], "int32", "width"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["height"], "int32", "height"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["password"], "string", "password"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["width"].(int32); localVarOk {
		localVarQueryParams.Add("width", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["height"].(int32); localVarOk {
		localVarQueryParams.Add("height", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["password"].(string); localVarOk {
		localVarQueryParams.Add("password", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Convert document page to Jpeg image and return resulting file in response.
 @param name The document name.
 @param pageNumber The page number.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "width" (int32) The converted image width.
     @param "height" (int32) The converted image height.
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
     @param "password" (string) The password (Base64).
 @return []byte*/
func (a *PdfApiService) GetPageConvertToJpeg(name string, pageNumber int32, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/convert/jpeg"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["width"], "int32", "width"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["height"], "int32", "height"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["password"], "string", "password"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["width"].(int32); localVarOk {
		localVarQueryParams.Add("width", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["height"].(int32); localVarOk {
		localVarQueryParams.Add("height", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["password"].(string); localVarOk {
		localVarQueryParams.Add("password", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Convert document page to Png image and return resulting file in response.
 @param name The document name.
 @param pageNumber The page number.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "width" (int32) The converted image width.
     @param "height" (int32) The converted image height.
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
     @param "password" (string) The password (Base64).
 @return []byte*/
func (a *PdfApiService) GetPageConvertToPng(name string, pageNumber int32, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/convert/png"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["width"], "int32", "width"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["height"], "int32", "height"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["password"], "string", "password"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["width"].(int32); localVarOk {
		localVarQueryParams.Add("width", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["height"].(int32); localVarOk {
		localVarQueryParams.Add("height", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["password"].(string); localVarOk {
		localVarQueryParams.Add("password", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Convert document page to Tiff image  and return resulting file in response.
 @param name The document name.
 @param pageNumber The page number.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "width" (int32) The converted image width.
     @param "height" (int32) The converted image height.
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
     @param "password" (string) The password (Base64).
 @return []byte*/
func (a *PdfApiService) GetPageConvertToTiff(name string, pageNumber int32, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/convert/tiff"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["width"], "int32", "width"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["height"], "int32", "height"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["password"], "string", "password"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["width"].(int32); localVarOk {
		localVarQueryParams.Add("width", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["height"].(int32); localVarOk {
		localVarQueryParams.Add("height", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["password"].(string); localVarOk {
		localVarQueryParams.Add("password", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page FileAttachment annotations.
 @param name The document name.
 @param pageNumber The page number.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return FileAttachmentAnnotationsResponse*/
func (a *PdfApiService) GetPageFileAttachmentAnnotations(name string, pageNumber int32, localVarOptionals map[string]interface{}) (FileAttachmentAnnotationsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload FileAttachmentAnnotationsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/annotations/fileattachment"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page free text annotations.
 @param name The document name.
 @param pageNumber The page number.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return FreeTextAnnotationsResponse*/
func (a *PdfApiService) GetPageFreeTextAnnotations(name string, pageNumber int32, localVarOptionals map[string]interface{}) (FreeTextAnnotationsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload FreeTextAnnotationsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/annotations/freetext"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page highlight annotations.
 @param name The document name.
 @param pageNumber The page number.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return HighlightAnnotationsResponse*/
func (a *PdfApiService) GetPageHighlightAnnotations(name string, pageNumber int32, localVarOptionals map[string]interface{}) (HighlightAnnotationsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload HighlightAnnotationsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/annotations/highlight"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page ink annotations.
 @param name The document name.
 @param pageNumber The page number.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return InkAnnotationsResponse*/
func (a *PdfApiService) GetPageInkAnnotations(name string, pageNumber int32, localVarOptionals map[string]interface{}) (InkAnnotationsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload InkAnnotationsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/annotations/ink"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page line annotations.
 @param name The document name.
 @param pageNumber The page number.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return LineAnnotationsResponse*/
func (a *PdfApiService) GetPageLineAnnotations(name string, pageNumber int32, localVarOptionals map[string]interface{}) (LineAnnotationsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload LineAnnotationsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/annotations/line"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page link annotation by ID.
 @param name The document name.
 @param pageNumber The page number.
 @param linkId The link ID.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return LinkAnnotationResponse*/
func (a *PdfApiService) GetPageLinkAnnotation(name string, pageNumber int32, linkId string, localVarOptionals map[string]interface{}) (LinkAnnotationResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload LinkAnnotationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/links/{linkId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"linkId"+"}", fmt.Sprintf("%v", linkId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page link annotations.
 @param name The document name.
 @param pageNumber The page number.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return LinkAnnotationsResponse*/
func (a *PdfApiService) GetPageLinkAnnotations(name string, pageNumber int32, localVarOptionals map[string]interface{}) (LinkAnnotationsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload LinkAnnotationsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/links"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page listbox fields.
 @param name The document name.
 @param pageNumber The page number.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return ListBoxFieldsResponse*/
func (a *PdfApiService) GetPageListBoxFields(name string, pageNumber int32, localVarOptionals map[string]interface{}) (ListBoxFieldsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload ListBoxFieldsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/page/{pageNumber}/fields/listbox"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page movie annotations.
 @param name The document name.
 @param pageNumber The page number.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return MovieAnnotationsResponse*/
func (a *PdfApiService) GetPageMovieAnnotations(name string, pageNumber int32, localVarOptionals map[string]interface{}) (MovieAnnotationsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload MovieAnnotationsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/annotations/movie"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page polyline annotations.
 @param name The document name.
 @param pageNumber The page number.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return PolyLineAnnotationsResponse*/
func (a *PdfApiService) GetPagePolyLineAnnotations(name string, pageNumber int32, localVarOptionals map[string]interface{}) (PolyLineAnnotationsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload PolyLineAnnotationsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/annotations/polyline"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page polygon annotations.
 @param name The document name.
 @param pageNumber The page number.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return PolygonAnnotationsResponse*/
func (a *PdfApiService) GetPagePolygonAnnotations(name string, pageNumber int32, localVarOptionals map[string]interface{}) (PolygonAnnotationsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload PolygonAnnotationsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/annotations/polygon"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page popup annotations.
 @param name The document name.
 @param pageNumber The page number.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return PopupAnnotationsResponse*/
func (a *PdfApiService) GetPagePopupAnnotations(name string, pageNumber int32, localVarOptionals map[string]interface{}) (PopupAnnotationsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload PopupAnnotationsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/annotations/popup"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page radiobutton fields.
 @param name The document name.
 @param pageNumber The page number.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return RadioButtonFieldsResponse*/
func (a *PdfApiService) GetPageRadioButtonFields(name string, pageNumber int32, localVarOptionals map[string]interface{}) (RadioButtonFieldsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload RadioButtonFieldsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/page/{pageNumber}/fields/radiobutton"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page redaction annotations.
 @param name The document name.
 @param pageNumber The page number.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return RedactionAnnotationsResponse*/
func (a *PdfApiService) GetPageRedactionAnnotations(name string, pageNumber int32, localVarOptionals map[string]interface{}) (RedactionAnnotationsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload RedactionAnnotationsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/annotations/redaction"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page screen annotations.
 @param name The document name.
 @param pageNumber The page number.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return ScreenAnnotationsResponse*/
func (a *PdfApiService) GetPageScreenAnnotations(name string, pageNumber int32, localVarOptionals map[string]interface{}) (ScreenAnnotationsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload ScreenAnnotationsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/annotations/screen"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page signature fields.
 @param name The document name.
 @param pageNumber The page number.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return SignatureFieldsResponse*/
func (a *PdfApiService) GetPageSignatureFields(name string, pageNumber int32, localVarOptionals map[string]interface{}) (SignatureFieldsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload SignatureFieldsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/page/{pageNumber}/fields/signature"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page sound annotations.
 @param name The document name.
 @param pageNumber The page number.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return SoundAnnotationsResponse*/
func (a *PdfApiService) GetPageSoundAnnotations(name string, pageNumber int32, localVarOptionals map[string]interface{}) (SoundAnnotationsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload SoundAnnotationsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/annotations/sound"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page square annotations.
 @param name The document name.
 @param pageNumber The page number.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return SquareAnnotationsResponse*/
func (a *PdfApiService) GetPageSquareAnnotations(name string, pageNumber int32, localVarOptionals map[string]interface{}) (SquareAnnotationsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload SquareAnnotationsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/annotations/square"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page squiggly annotations.
 @param name The document name.
 @param pageNumber The page number.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return SquigglyAnnotationsResponse*/
func (a *PdfApiService) GetPageSquigglyAnnotations(name string, pageNumber int32, localVarOptionals map[string]interface{}) (SquigglyAnnotationsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload SquigglyAnnotationsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/annotations/squiggly"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page stamp annotations.
 @param name The document name.
 @param pageNumber The page number.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return StampAnnotationsResponse*/
func (a *PdfApiService) GetPageStampAnnotations(name string, pageNumber int32, localVarOptionals map[string]interface{}) (StampAnnotationsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload StampAnnotationsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/annotations/stamp"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read page document stamps.
 @param name The document name.
 @param pageNumber The page number.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return StampsInfoResponse*/
func (a *PdfApiService) GetPageStamps(name string, pageNumber int32, localVarOptionals map[string]interface{}) (StampsInfoResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload StampsInfoResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/stamps"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page StrikeOut annotations.
 @param name The document name.
 @param pageNumber The page number.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return StrikeOutAnnotationsResponse*/
func (a *PdfApiService) GetPageStrikeOutAnnotations(name string, pageNumber int32, localVarOptionals map[string]interface{}) (StrikeOutAnnotationsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload StrikeOutAnnotationsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/annotations/strikeout"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page tables.
 @param name 
 @param pageNumber 
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) 
     @param "folder" (string) 
 @return TablesRecognizedResponse*/
func (a *PdfApiService) GetPageTables(name string, pageNumber int32, localVarOptionals map[string]interface{}) (TablesRecognizedResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload TablesRecognizedResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/tables"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read page text items.
 @param name The document name.
 @param pageNumber Number of page (starting from 1).
 @param lLX X-coordinate of lower - left corner.
 @param lLY Y - coordinate of lower-left corner.
 @param uRX X - coordinate of upper-right corner.
 @param uRY Y - coordinate of upper-right corner.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "format" ([]string) List of formats for search.
     @param "regex" (string) Formats are specified as a regular expression.
     @param "splitRects" (bool) Split result fragments (default is true).
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
 @return TextRectsResponse*/
func (a *PdfApiService) GetPageText(name string, pageNumber int32, lLX float64, lLY float64, uRX float64, uRY float64, localVarOptionals map[string]interface{}) (TextRectsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload TextRectsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/text"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["regex"], "string", "regex"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["splitRects"], "bool", "splitRects"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["format"].([]string); localVarOk {
		localVarQueryParams.Add("format", parameterToString(localVarTempParam, "csv"))
	}
	if localVarTempParam, localVarOk := localVarOptionals["regex"].(string); localVarOk {
		localVarQueryParams.Add("regex", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["splitRects"].(bool); localVarOk {
		localVarQueryParams.Add("splitRects", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	localVarQueryParams.Add("LLX", parameterToString(lLX, ""))
	localVarQueryParams.Add("LLY", parameterToString(lLY, ""))
	localVarQueryParams.Add("URX", parameterToString(uRX, ""))
	localVarQueryParams.Add("URY", parameterToString(uRY, ""))
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page text annotations.
 @param name The document name.
 @param pageNumber The page number.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return TextAnnotationsResponse*/
func (a *PdfApiService) GetPageTextAnnotations(name string, pageNumber int32, localVarOptionals map[string]interface{}) (TextAnnotationsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload TextAnnotationsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/annotations/text"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page text box fields.
 @param name The document name.
 @param pageNumber The page number.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return TextBoxFieldsResponse*/
func (a *PdfApiService) GetPageTextBoxFields(name string, pageNumber int32, localVarOptionals map[string]interface{}) (TextBoxFieldsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload TextBoxFieldsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/page/{pageNumber}/fields/textbox"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page underline annotations.
 @param name The document name.
 @param pageNumber The page number.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return UnderlineAnnotationsResponse*/
func (a *PdfApiService) GetPageUnderlineAnnotations(name string, pageNumber int32, localVarOptionals map[string]interface{}) (UnderlineAnnotationsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload UnderlineAnnotationsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/annotations/underline"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document pages info.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return DocumentPagesResponse*/
func (a *PdfApiService) GetPages(name string, localVarOptionals map[string]interface{}) (DocumentPagesResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload DocumentPagesResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Convert PCL file (located on storage) to PDF format and return resulting file in response. 
 @param srcPath Full source filename (ex. /folder1/folder2/template.pcl)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
 @return []byte*/
func (a *PdfApiService) GetPclInStorageToPdf(srcPath string, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/create/pcl"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("srcPath", parameterToString(srcPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Convert PDFA file (located on storage) to PDF format and return resulting file in response. 
 @param srcPath Full source filename (ex. /folder1/folder2/template.pdf)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "dontOptimize" (bool) If set, document resources will not be optimized.
     @param "storage" (string) The document storage.
 @return []byte*/
func (a *PdfApiService) GetPdfAInStorageToPdf(srcPath string, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/create/pdfa"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["dontOptimize"], "bool", "dontOptimize"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("srcPath", parameterToString(srcPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["dontOptimize"].(bool); localVarOk {
		localVarQueryParams.Add("dontOptimize", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Converts PDF document (located on storage) to DOC format and returns resulting file in response content.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "addReturnToLineEnd" (bool) Add return to line end.
     @param "format" (string) Allows to specify .doc or .docx file format.
     @param "imageResolutionX" (int32) Image resolution X.
     @param "imageResolutionY" (int32) Image resolution Y.
     @param "maxDistanceBetweenTextLines" (float64) Max distance between text lines.
     @param "mode" (string) Allows to control how a PDF document is converted into a word processing document.
     @param "recognizeBullets" (bool) Recognize bullets.
     @param "relativeHorizontalProximity" (float64) Relative horizontal proximity.
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
     @param "password" (string) The password (Base64).
 @return []byte*/
func (a *PdfApiService) GetPdfInStorageToDoc(name string, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/convert/doc"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["addReturnToLineEnd"], "bool", "addReturnToLineEnd"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["format"], "string", "format"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["imageResolutionX"], "int32", "imageResolutionX"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["imageResolutionY"], "int32", "imageResolutionY"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["maxDistanceBetweenTextLines"], "float64", "maxDistanceBetweenTextLines"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["mode"], "string", "mode"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["recognizeBullets"], "bool", "recognizeBullets"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["relativeHorizontalProximity"], "float64", "relativeHorizontalProximity"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["password"], "string", "password"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["addReturnToLineEnd"].(bool); localVarOk {
		localVarQueryParams.Add("addReturnToLineEnd", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["format"].(string); localVarOk {
		localVarQueryParams.Add("format", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["imageResolutionX"].(int32); localVarOk {
		localVarQueryParams.Add("imageResolutionX", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["imageResolutionY"].(int32); localVarOk {
		localVarQueryParams.Add("imageResolutionY", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["maxDistanceBetweenTextLines"].(float64); localVarOk {
		localVarQueryParams.Add("maxDistanceBetweenTextLines", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["mode"].(string); localVarOk {
		localVarQueryParams.Add("mode", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["recognizeBullets"].(bool); localVarOk {
		localVarQueryParams.Add("recognizeBullets", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["relativeHorizontalProximity"].(float64); localVarOk {
		localVarQueryParams.Add("relativeHorizontalProximity", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["password"].(string); localVarOk {
		localVarQueryParams.Add("password", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Converts PDF document (located on storage) to EPUB format and returns resulting file in response content
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "contentRecognitionMode" (string) Property tunes conversion for this or that desirable method of recognition of content.
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
 @return []byte*/
func (a *PdfApiService) GetPdfInStorageToEpub(name string, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/convert/epub"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["contentRecognitionMode"], "string", "contentRecognitionMode"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["contentRecognitionMode"].(string); localVarOk {
		localVarQueryParams.Add("contentRecognitionMode", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Converts PDF document (located on storage) to Html format and returns resulting file in response content
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "additionalMarginWidthInPoints" (int32) Defines width of margin that will be forcibly left around that output HTML-areas.
     @param "compressSvgGraphicsIfAny" (bool) The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving.
     @param "convertMarkedContentToLayers" (bool) If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content.
     @param "defaultFontName" (string) Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used.
     @param "documentType" (string) Result document type.
     @param "fixedLayout" (bool) The value indicating whether that HTML is created as fixed layout.
     @param "imageResolution" (int32) Resolution for image rendering.
     @param "minimalLineWidth" (int32) This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers.
     @param "preventGlyphsGrouping" (bool) This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true.
     @param "splitCssIntoPages" (bool) When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page.
     @param "splitIntoPages" (bool) The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages.
     @param "useZOrder" (bool) If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects.
     @param "antialiasingProcessing" (string) The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML.
     @param "cssClassNamesPrefix" (string) When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix.
     @param "explicitListOfSavedPages" ([]int32) With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF.
     @param "fontEncodingStrategy" (string) Defines encoding special rule to tune PDF decoding for current document.
     @param "fontSavingMode" (string) Defines font saving mode that will be used during saving of PDF to desirable format.
     @param "htmlMarkupGenerationMode" (string) Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments.
     @param "lettersPositioningMethod" (string) The mode of positioning of letters in words in result HTML.
     @param "pagesFlowTypeDependsOnViewersScreenSize" (bool) If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer.
     @param "partsEmbeddingMode" (string) It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities.
     @param "rasterImagesSavingMode" (string) Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML.
     @param "removeEmptyAreasOnTopAndBottom" (bool) Defines whether in created HTML will be removed top and bottom empty area without any content (if any).
     @param "saveShadowedTextsAsTransparentTexts" (bool) Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard).
     @param "saveTransparentTexts" (bool) Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML.
     @param "specialFolderForAllImages" (string) The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file.
     @param "specialFolderForSvgImages" (string) The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file.
     @param "trySaveTextUnderliningAndStrikeoutingInCss" (bool) PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically.
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
     @param "flowLayoutParagraphFullWidth" (bool) This attribute specifies full width paragraph text for Flow mode, FixedLayout &#x3D; false.
 @return []byte*/
func (a *PdfApiService) GetPdfInStorageToHtml(name string, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/convert/html"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["additionalMarginWidthInPoints"], "int32", "additionalMarginWidthInPoints"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["compressSvgGraphicsIfAny"], "bool", "compressSvgGraphicsIfAny"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["convertMarkedContentToLayers"], "bool", "convertMarkedContentToLayers"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["defaultFontName"], "string", "defaultFontName"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["documentType"], "string", "documentType"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["fixedLayout"], "bool", "fixedLayout"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["imageResolution"], "int32", "imageResolution"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["minimalLineWidth"], "int32", "minimalLineWidth"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["preventGlyphsGrouping"], "bool", "preventGlyphsGrouping"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["splitCssIntoPages"], "bool", "splitCssIntoPages"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["splitIntoPages"], "bool", "splitIntoPages"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["useZOrder"], "bool", "useZOrder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["antialiasingProcessing"], "string", "antialiasingProcessing"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["cssClassNamesPrefix"], "string", "cssClassNamesPrefix"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["fontEncodingStrategy"], "string", "fontEncodingStrategy"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["fontSavingMode"], "string", "fontSavingMode"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["htmlMarkupGenerationMode"], "string", "htmlMarkupGenerationMode"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["lettersPositioningMethod"], "string", "lettersPositioningMethod"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["pagesFlowTypeDependsOnViewersScreenSize"], "bool", "pagesFlowTypeDependsOnViewersScreenSize"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["partsEmbeddingMode"], "string", "partsEmbeddingMode"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["rasterImagesSavingMode"], "string", "rasterImagesSavingMode"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["removeEmptyAreasOnTopAndBottom"], "bool", "removeEmptyAreasOnTopAndBottom"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["saveShadowedTextsAsTransparentTexts"], "bool", "saveShadowedTextsAsTransparentTexts"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["saveTransparentTexts"], "bool", "saveTransparentTexts"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["specialFolderForAllImages"], "string", "specialFolderForAllImages"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["specialFolderForSvgImages"], "string", "specialFolderForSvgImages"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["trySaveTextUnderliningAndStrikeoutingInCss"], "bool", "trySaveTextUnderliningAndStrikeoutingInCss"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["flowLayoutParagraphFullWidth"], "bool", "flowLayoutParagraphFullWidth"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["additionalMarginWidthInPoints"].(int32); localVarOk {
		localVarQueryParams.Add("additionalMarginWidthInPoints", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["compressSvgGraphicsIfAny"].(bool); localVarOk {
		localVarQueryParams.Add("compressSvgGraphicsIfAny", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["convertMarkedContentToLayers"].(bool); localVarOk {
		localVarQueryParams.Add("convertMarkedContentToLayers", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["defaultFontName"].(string); localVarOk {
		localVarQueryParams.Add("defaultFontName", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["documentType"].(string); localVarOk {
		localVarQueryParams.Add("documentType", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["fixedLayout"].(bool); localVarOk {
		localVarQueryParams.Add("fixedLayout", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["imageResolution"].(int32); localVarOk {
		localVarQueryParams.Add("imageResolution", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["minimalLineWidth"].(int32); localVarOk {
		localVarQueryParams.Add("minimalLineWidth", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["preventGlyphsGrouping"].(bool); localVarOk {
		localVarQueryParams.Add("preventGlyphsGrouping", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["splitCssIntoPages"].(bool); localVarOk {
		localVarQueryParams.Add("splitCssIntoPages", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["splitIntoPages"].(bool); localVarOk {
		localVarQueryParams.Add("splitIntoPages", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["useZOrder"].(bool); localVarOk {
		localVarQueryParams.Add("useZOrder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["antialiasingProcessing"].(string); localVarOk {
		localVarQueryParams.Add("antialiasingProcessing", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["cssClassNamesPrefix"].(string); localVarOk {
		localVarQueryParams.Add("cssClassNamesPrefix", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["explicitListOfSavedPages"].([]int32); localVarOk {
		localVarQueryParams.Add("explicitListOfSavedPages", parameterToString(localVarTempParam, "csv"))
	}
	if localVarTempParam, localVarOk := localVarOptionals["fontEncodingStrategy"].(string); localVarOk {
		localVarQueryParams.Add("fontEncodingStrategy", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["fontSavingMode"].(string); localVarOk {
		localVarQueryParams.Add("fontSavingMode", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["htmlMarkupGenerationMode"].(string); localVarOk {
		localVarQueryParams.Add("htmlMarkupGenerationMode", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["lettersPositioningMethod"].(string); localVarOk {
		localVarQueryParams.Add("lettersPositioningMethod", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["pagesFlowTypeDependsOnViewersScreenSize"].(bool); localVarOk {
		localVarQueryParams.Add("pagesFlowTypeDependsOnViewersScreenSize", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["partsEmbeddingMode"].(string); localVarOk {
		localVarQueryParams.Add("partsEmbeddingMode", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["rasterImagesSavingMode"].(string); localVarOk {
		localVarQueryParams.Add("rasterImagesSavingMode", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["removeEmptyAreasOnTopAndBottom"].(bool); localVarOk {
		localVarQueryParams.Add("removeEmptyAreasOnTopAndBottom", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["saveShadowedTextsAsTransparentTexts"].(bool); localVarOk {
		localVarQueryParams.Add("saveShadowedTextsAsTransparentTexts", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["saveTransparentTexts"].(bool); localVarOk {
		localVarQueryParams.Add("saveTransparentTexts", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["specialFolderForAllImages"].(string); localVarOk {
		localVarQueryParams.Add("specialFolderForAllImages", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["specialFolderForSvgImages"].(string); localVarOk {
		localVarQueryParams.Add("specialFolderForSvgImages", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["trySaveTextUnderliningAndStrikeoutingInCss"].(bool); localVarOk {
		localVarQueryParams.Add("trySaveTextUnderliningAndStrikeoutingInCss", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["flowLayoutParagraphFullWidth"].(bool); localVarOk {
		localVarQueryParams.Add("flowLayoutParagraphFullWidth", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Converts PDF document (located on storage) to MOBIXML format and returns resulting ZIP archive file in response content.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
 @return []byte*/
func (a *PdfApiService) GetPdfInStorageToMobiXml(name string, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/convert/mobixml"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Converts PDF document (located on storage) to PdfA format and returns resulting file in response content
 @param name The document name.
 @param type_ Type of PdfA format.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
 @return []byte*/
func (a *PdfApiService) GetPdfInStorageToPdfA(name string, type_ string, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/convert/pdfa"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("type", parameterToString(type_, ""))
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Converts PDF document (located on storage) to PPTX format and returns resulting file in response content
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "separateImages" (bool) Separate images.
     @param "slidesAsImages" (bool) Slides as images.
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
     @param "password" (string) Base64 encoded password.
 @return []byte*/
func (a *PdfApiService) GetPdfInStorageToPptx(name string, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/convert/pptx"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["separateImages"], "bool", "separateImages"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["slidesAsImages"], "bool", "slidesAsImages"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["password"], "string", "password"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["separateImages"].(bool); localVarOk {
		localVarQueryParams.Add("separateImages", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["slidesAsImages"].(bool); localVarOk {
		localVarQueryParams.Add("slidesAsImages", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["password"].(string); localVarOk {
		localVarQueryParams.Add("password", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Converts PDF document (located on storage) to SVG format and returns resulting file in response content
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "compressOutputToZipArchive" (bool) Specifies whether output will be created as one zip-archive.
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
 @return []byte*/
func (a *PdfApiService) GetPdfInStorageToSvg(name string, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/convert/svg"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["compressOutputToZipArchive"], "bool", "compressOutputToZipArchive"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["compressOutputToZipArchive"].(bool); localVarOk {
		localVarQueryParams.Add("compressOutputToZipArchive", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Converts PDF document (located on storage) to TeX format and returns resulting file in response content
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
 @return []byte*/
func (a *PdfApiService) GetPdfInStorageToTeX(name string, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/convert/tex"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Converts PDF document (located on storage) to TIFF format and returns resulting file in response content
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "brightness" (float64) Image brightness.
     @param "compression" (string) Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None.
     @param "colorDepth" (string) Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp.
     @param "leftMargin" (int32) Left image margin.
     @param "rightMargin" (int32) Right image margin.
     @param "topMargin" (int32) Top image margin.
     @param "bottomMargin" (int32) Bottom image margin.
     @param "orientation" (string) Image orientation. Possible values are: None, Landscape, Portait.
     @param "skipBlankPages" (bool) Skip blank pages flag.
     @param "width" (int32) Image width.
     @param "height" (int32) Image height.
     @param "xResolution" (int32) Horizontal resolution.
     @param "yResolution" (int32) Vertical resolution.
     @param "pageIndex" (int32) Start page to export.
     @param "pageCount" (int32) Number of pages to export.
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
 @return []byte*/
func (a *PdfApiService) GetPdfInStorageToTiff(name string, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/convert/tiff"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["brightness"], "float64", "brightness"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["compression"], "string", "compression"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["colorDepth"], "string", "colorDepth"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["leftMargin"], "int32", "leftMargin"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["rightMargin"], "int32", "rightMargin"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["topMargin"], "int32", "topMargin"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["bottomMargin"], "int32", "bottomMargin"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["orientation"], "string", "orientation"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["skipBlankPages"], "bool", "skipBlankPages"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["width"], "int32", "width"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["height"], "int32", "height"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["xResolution"], "int32", "xResolution"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["yResolution"], "int32", "yResolution"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["pageIndex"], "int32", "pageIndex"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["pageCount"], "int32", "pageCount"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["brightness"].(float64); localVarOk {
		localVarQueryParams.Add("brightness", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["compression"].(string); localVarOk {
		localVarQueryParams.Add("compression", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["colorDepth"].(string); localVarOk {
		localVarQueryParams.Add("colorDepth", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["leftMargin"].(int32); localVarOk {
		localVarQueryParams.Add("leftMargin", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["rightMargin"].(int32); localVarOk {
		localVarQueryParams.Add("rightMargin", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["topMargin"].(int32); localVarOk {
		localVarQueryParams.Add("topMargin", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["bottomMargin"].(int32); localVarOk {
		localVarQueryParams.Add("bottomMargin", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["orientation"].(string); localVarOk {
		localVarQueryParams.Add("orientation", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["skipBlankPages"].(bool); localVarOk {
		localVarQueryParams.Add("skipBlankPages", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["width"].(int32); localVarOk {
		localVarQueryParams.Add("width", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["height"].(int32); localVarOk {
		localVarQueryParams.Add("height", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["xResolution"].(int32); localVarOk {
		localVarQueryParams.Add("xResolution", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["yResolution"].(int32); localVarOk {
		localVarQueryParams.Add("yResolution", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["pageIndex"].(int32); localVarOk {
		localVarQueryParams.Add("pageIndex", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["pageCount"].(int32); localVarOk {
		localVarQueryParams.Add("pageCount", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Converts PDF document (located on storage) to XLS format and returns resulting file in response content
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "insertBlankColumnAtFirst" (bool) Insert blank column at first
     @param "minimizeTheNumberOfWorksheets" (bool) Minimize the number of worksheets
     @param "scaleFactor" (float64) Scale factor (Obsolete)
     @param "uniformWorksheets" (bool) Uniform worksheets
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
     @param "password" (string) The password (Base64).
 @return []byte*/
func (a *PdfApiService) GetPdfInStorageToXls(name string, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/convert/xls"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["insertBlankColumnAtFirst"], "bool", "insertBlankColumnAtFirst"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["minimizeTheNumberOfWorksheets"], "bool", "minimizeTheNumberOfWorksheets"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["scaleFactor"], "float64", "scaleFactor"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["uniformWorksheets"], "bool", "uniformWorksheets"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["password"], "string", "password"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["insertBlankColumnAtFirst"].(bool); localVarOk {
		localVarQueryParams.Add("insertBlankColumnAtFirst", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["minimizeTheNumberOfWorksheets"].(bool); localVarOk {
		localVarQueryParams.Add("minimizeTheNumberOfWorksheets", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["scaleFactor"].(float64); localVarOk {
		localVarQueryParams.Add("scaleFactor", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["uniformWorksheets"].(bool); localVarOk {
		localVarQueryParams.Add("uniformWorksheets", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["password"].(string); localVarOk {
		localVarQueryParams.Add("password", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Converts PDF document (located on storage) to XLSX format and returns resulting file in response content
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "insertBlankColumnAtFirst" (bool) Insert blank column at first
     @param "minimizeTheNumberOfWorksheets" (bool) Minimize the number of worksheets
     @param "scaleFactor" (float64) Scale factor (Obsolete)
     @param "uniformWorksheets" (bool) Uniform worksheets
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
     @param "password" (string) The password (Base64).
 @return []byte*/
func (a *PdfApiService) GetPdfInStorageToXlsx(name string, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/convert/xlsx"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["insertBlankColumnAtFirst"], "bool", "insertBlankColumnAtFirst"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["minimizeTheNumberOfWorksheets"], "bool", "minimizeTheNumberOfWorksheets"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["scaleFactor"], "float64", "scaleFactor"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["uniformWorksheets"], "bool", "uniformWorksheets"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["password"], "string", "password"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["insertBlankColumnAtFirst"].(bool); localVarOk {
		localVarQueryParams.Add("insertBlankColumnAtFirst", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["minimizeTheNumberOfWorksheets"].(bool); localVarOk {
		localVarQueryParams.Add("minimizeTheNumberOfWorksheets", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["scaleFactor"].(float64); localVarOk {
		localVarQueryParams.Add("scaleFactor", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["uniformWorksheets"].(bool); localVarOk {
		localVarQueryParams.Add("uniformWorksheets", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["password"].(string); localVarOk {
		localVarQueryParams.Add("password", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Converts PDF document (located on storage) to XML format and returns resulting file in response content
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
 @return []byte*/
func (a *PdfApiService) GetPdfInStorageToXml(name string, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/convert/xml"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Converts PDF document (located on storage) to XPS format and returns resulting file in response content
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
 @return []byte*/
func (a *PdfApiService) GetPdfInStorageToXps(name string, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/convert/xps"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page polyline annotation by ID.
 @param name The document name.
 @param annotationId The annotation ID.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return PolyLineAnnotationResponse*/
func (a *PdfApiService) GetPolyLineAnnotation(name string, annotationId string, localVarOptionals map[string]interface{}) (PolyLineAnnotationResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload PolyLineAnnotationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/polyline/{annotationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page polygon annotation by ID.
 @param name The document name.
 @param annotationId The annotation ID.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return PolygonAnnotationResponse*/
func (a *PdfApiService) GetPolygonAnnotation(name string, annotationId string, localVarOptionals map[string]interface{}) (PolygonAnnotationResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload PolygonAnnotationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/polygon/{annotationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page popup annotation by ID.
 @param name The document name.
 @param annotationId The annotation ID.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return PopupAnnotationResponse*/
func (a *PdfApiService) GetPopupAnnotation(name string, annotationId string, localVarOptionals map[string]interface{}) (PopupAnnotationResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload PopupAnnotationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/popup/{annotationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Convert PS file (located on storage) to PDF format and return resulting file in response. 
 @param srcPath Full source filename (ex. /folder1/folder2/template.ps)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
 @return []byte*/
func (a *PdfApiService) GetPsInStorageToPdf(srcPath string, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/create/ps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("srcPath", parameterToString(srcPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document RadioButton field by name.
 @param name The document name.
 @param fieldName The field name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return RadioButtonFieldResponse*/
func (a *PdfApiService) GetRadioButtonField(name string, fieldName string, localVarOptionals map[string]interface{}) (RadioButtonFieldResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload RadioButtonFieldResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/fields/radiobutton/{fieldName}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fieldName"+"}", fmt.Sprintf("%v", fieldName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page redaction annotation by ID.
 @param name The document name.
 @param annotationId The annotation ID.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return RedactionAnnotationResponse*/
func (a *PdfApiService) GetRedactionAnnotation(name string, annotationId string, localVarOptionals map[string]interface{}) (RedactionAnnotationResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload RedactionAnnotationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/redaction/{annotationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page screen annotation by ID.
 @param name The document name.
 @param annotationId The annotation ID.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return ScreenAnnotationResponse*/
func (a *PdfApiService) GetScreenAnnotation(name string, annotationId string, localVarOptionals map[string]interface{}) (ScreenAnnotationResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload ScreenAnnotationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/screen/{annotationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page screen annotation by ID.
 @param name The document name.
 @param annotationId The annotation ID.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return []byte*/
func (a *PdfApiService) GetScreenAnnotationData(name string, annotationId string, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/screen/{annotationId}/data"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document signature field by name.
 @param name The document name.
 @param fieldName The field name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return SignatureFieldResponse*/
func (a *PdfApiService) GetSignatureField(name string, fieldName string, localVarOptionals map[string]interface{}) (SignatureFieldResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload SignatureFieldResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/fields/signature/{fieldName}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fieldName"+"}", fmt.Sprintf("%v", fieldName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page sound annotation by ID.
 @param name The document name.
 @param annotationId The annotation ID.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return SoundAnnotationResponse*/
func (a *PdfApiService) GetSoundAnnotation(name string, annotationId string, localVarOptionals map[string]interface{}) (SoundAnnotationResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload SoundAnnotationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/sound/{annotationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page sound annotation by ID.
 @param name The document name.
 @param annotationId The annotation ID.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return []byte*/
func (a *PdfApiService) GetSoundAnnotationData(name string, annotationId string, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/sound/{annotationId}/data"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page square annotation by ID.
 @param name The document name.
 @param annotationId The annotation ID.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return SquareAnnotationResponse*/
func (a *PdfApiService) GetSquareAnnotation(name string, annotationId string, localVarOptionals map[string]interface{}) (SquareAnnotationResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload SquareAnnotationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/square/{annotationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page squiggly annotation by ID.
 @param name The document name.
 @param annotationId The annotation ID.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return SquigglyAnnotationResponse*/
func (a *PdfApiService) GetSquigglyAnnotation(name string, annotationId string, localVarOptionals map[string]interface{}) (SquigglyAnnotationResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload SquigglyAnnotationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/squiggly/{annotationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page stamp annotation by ID.
 @param name The document name.
 @param annotationId The annotation ID.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return StampAnnotationResponse*/
func (a *PdfApiService) GetStampAnnotation(name string, annotationId string, localVarOptionals map[string]interface{}) (StampAnnotationResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload StampAnnotationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/stamp/{annotationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page stamp annotation by ID.
 @param name The document name.
 @param annotationId The annotation ID.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return []byte*/
func (a *PdfApiService) GetStampAnnotationData(name string, annotationId string, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/stamp/{annotationId}/data"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page StrikeOut annotation by ID.
 @param name The document name.
 @param annotationId The annotation ID.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return StrikeOutAnnotationResponse*/
func (a *PdfApiService) GetStrikeOutAnnotation(name string, annotationId string, localVarOptionals map[string]interface{}) (StrikeOutAnnotationResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload StrikeOutAnnotationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/strikeout/{annotationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Convert SVG file (located on storage) to PDF format and return resulting file in response. 
 @param srcPath Full source filename (ex. /folder1/folder2/template.svg)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "adjustPageSize" (bool) Adjust page size
     @param "height" (float64) Page height
     @param "width" (float64) Page width
     @param "isLandscape" (bool) Is page landscaped
     @param "marginLeft" (float64) Page margin left
     @param "marginBottom" (float64) Page margin bottom
     @param "marginRight" (float64) Page margin right
     @param "marginTop" (float64) Page margin top
     @param "storage" (string) The document storage.
 @return []byte*/
func (a *PdfApiService) GetSvgInStorageToPdf(srcPath string, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/create/svg"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["adjustPageSize"], "bool", "adjustPageSize"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["height"], "float64", "height"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["width"], "float64", "width"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["isLandscape"], "bool", "isLandscape"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["marginLeft"], "float64", "marginLeft"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["marginBottom"], "float64", "marginBottom"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["marginRight"], "float64", "marginRight"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["marginTop"], "float64", "marginTop"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("srcPath", parameterToString(srcPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["adjustPageSize"].(bool); localVarOk {
		localVarQueryParams.Add("adjustPageSize", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["height"].(float64); localVarOk {
		localVarQueryParams.Add("height", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["width"].(float64); localVarOk {
		localVarQueryParams.Add("width", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["isLandscape"].(bool); localVarOk {
		localVarQueryParams.Add("isLandscape", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["marginLeft"].(float64); localVarOk {
		localVarQueryParams.Add("marginLeft", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["marginBottom"].(float64); localVarOk {
		localVarQueryParams.Add("marginBottom", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["marginRight"].(float64); localVarOk {
		localVarQueryParams.Add("marginRight", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["marginTop"].(float64); localVarOk {
		localVarQueryParams.Add("marginTop", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page table by ID.
 @param name The document name.
 @param tableId The table ID.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return TableRecognizedResponse*/
func (a *PdfApiService) GetTable(name string, tableId string, localVarOptionals map[string]interface{}) (TableRecognizedResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload TableRecognizedResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/tables/{tableId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tableId"+"}", fmt.Sprintf("%v", tableId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Convert TeX file (located on storage) to PDF format and return resulting file in response. 
 @param srcPath Full source filename (ex. /folder1/folder2/template.tex)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
 @return []byte*/
func (a *PdfApiService) GetTeXInStorageToPdf(srcPath string, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/create/tex"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("srcPath", parameterToString(srcPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document text.
 @param name The document name.
 @param lLX X-coordinate of lower - left corner.
 @param lLY Y - coordinate of lower-left corner.
 @param uRX X - coordinate of upper-right corner.
 @param uRY Y - coordinate of upper-right corner.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "format" ([]string) List of formats for search.
     @param "regex" (string) Formats are specified as a regular expression.
     @param "splitRects" (bool) Split result fragments (default is true).
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
 @return TextRectsResponse*/
func (a *PdfApiService) GetText(name string, lLX float64, lLY float64, uRX float64, uRY float64, localVarOptionals map[string]interface{}) (TextRectsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload TextRectsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/text"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["regex"], "string", "regex"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["splitRects"], "bool", "splitRects"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["format"].([]string); localVarOk {
		localVarQueryParams.Add("format", parameterToString(localVarTempParam, "csv"))
	}
	if localVarTempParam, localVarOk := localVarOptionals["regex"].(string); localVarOk {
		localVarQueryParams.Add("regex", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["splitRects"].(bool); localVarOk {
		localVarQueryParams.Add("splitRects", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	localVarQueryParams.Add("LLX", parameterToString(lLX, ""))
	localVarQueryParams.Add("LLY", parameterToString(lLY, ""))
	localVarQueryParams.Add("URX", parameterToString(uRX, ""))
	localVarQueryParams.Add("URY", parameterToString(uRY, ""))
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page text annotation by ID.
 @param name The document name.
 @param annotationId The annotation ID.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return TextAnnotationResponse*/
func (a *PdfApiService) GetTextAnnotation(name string, annotationId string, localVarOptionals map[string]interface{}) (TextAnnotationResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload TextAnnotationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/text/{annotationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document text box field by name.
 @param name The document name.
 @param fieldName The field name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return TextBoxFieldResponse*/
func (a *PdfApiService) GetTextBoxField(name string, fieldName string, localVarOptionals map[string]interface{}) (TextBoxFieldResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload TextBoxFieldResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/fields/textbox/{fieldName}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fieldName"+"}", fmt.Sprintf("%v", fieldName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Read document page underline annotation by ID.
 @param name The document name.
 @param annotationId The annotation ID.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return UnderlineAnnotationResponse*/
func (a *PdfApiService) GetUnderlineAnnotation(name string, annotationId string, localVarOptionals map[string]interface{}) (UnderlineAnnotationResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload UnderlineAnnotationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/underline/{annotationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Verify signature document.
 @param name The document name.
 @param signName Sign name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return SignatureVerifyResponse*/
func (a *PdfApiService) GetVerifySignature(name string, signName string, localVarOptionals map[string]interface{}) (SignatureVerifyResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload SignatureVerifyResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/verifySignature"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("signName", parameterToString(signName, ""))
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Convert web page to PDF format and return resulting file in response. 
 @param url Source url
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "height" (float64) Page height
     @param "width" (float64) Page width
     @param "isLandscape" (bool) Is page landscaped
     @param "marginLeft" (float64) Page margin left
     @param "marginBottom" (float64) Page margin bottom
     @param "marginRight" (float64) Page margin right
     @param "marginTop" (float64) Page margin top
     @param "storage" (string) The document storage.
 @return []byte*/
func (a *PdfApiService) GetWebInStorageToPdf(url string, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/create/web"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["height"], "float64", "height"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["width"], "float64", "width"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["isLandscape"], "bool", "isLandscape"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["marginLeft"], "float64", "marginLeft"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["marginBottom"], "float64", "marginBottom"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["marginRight"], "float64", "marginRight"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["marginTop"], "float64", "marginTop"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("url", parameterToString(url, ""))
	if localVarTempParam, localVarOk := localVarOptionals["height"].(float64); localVarOk {
		localVarQueryParams.Add("height", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["width"].(float64); localVarOk {
		localVarQueryParams.Add("width", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["isLandscape"].(bool); localVarOk {
		localVarQueryParams.Add("isLandscape", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["marginLeft"].(float64); localVarOk {
		localVarQueryParams.Add("marginLeft", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["marginBottom"].(float64); localVarOk {
		localVarQueryParams.Add("marginBottom", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["marginRight"].(float64); localVarOk {
		localVarQueryParams.Add("marginRight", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["marginTop"].(float64); localVarOk {
		localVarQueryParams.Add("marginTop", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Get number of words per document page.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return WordCountResponse*/
func (a *PdfApiService) GetWordsPerPage(name string, localVarOptionals map[string]interface{}) (WordCountResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload WordCountResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/wordCount"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Converts PDF document which contains XFA form (located on storage) to PDF with AcroForm and returns resulting file response content
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
 @return []byte*/
func (a *PdfApiService) GetXfaPdfInStorageToAcroForm(name string, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/convert/xfatoacroform"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Convert XML file (located on storage) to PDF format and return resulting file in response. 
 @param srcPath Full source filename (ex. /folder1/folder2/template.xml)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "xslFilePath" (string) Full XSL source filename (ex. /folder1/folder2/template.xsl)
     @param "storage" (string) The document storage.
 @return []byte*/
func (a *PdfApiService) GetXmlInStorageToPdf(srcPath string, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/create/xml"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["xslFilePath"], "string", "xslFilePath"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("srcPath", parameterToString(srcPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["xslFilePath"].(string); localVarOk {
		localVarQueryParams.Add("xslFilePath", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Convert XPS file (located on storage) to PDF format and return resulting file in response. 
 @param srcPath Full source filename (ex. /folder1/folder2/template.xps)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
 @return []byte*/
func (a *PdfApiService) GetXpsInStorageToPdf(srcPath string, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/create/xps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("srcPath", parameterToString(srcPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Convert XslFo file (located on storage) to PDF format and return resulting file in response. 
 @param srcPath Full source filename (ex. /folder1/folder2/template.xslfo)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
 @return []byte*/
func (a *PdfApiService) GetXslFoInStorageToPdf(srcPath string, localVarOptionals map[string]interface{}) ([]byte,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/create/xslfo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("srcPath", parameterToString(srcPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"multipart/form-data",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    successPayload, err = ioutil.ReadAll(localVarHttpResponse.Body)
    if err != nil {
        return successPayload, localVarHttpResponse, err
    }

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Move file
 @param srcPath Source file path e.g. &#39;/src.ext&#39;
 @param destPath Destination file path e.g. &#39;/dest.ext&#39;
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "srcStorageName" (string) Source storage name
     @param "destStorageName" (string) Destination storage name
     @param "versionId" (string) File version ID to move
 @return */
func (a *PdfApiService) MoveFile(srcPath string, destPath string, localVarOptionals map[string]interface{}) ( *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/storage/file/move/{srcPath}"
	localVarPath = strings.Replace(localVarPath, "{"+"srcPath"+"}", fmt.Sprintf("%v", srcPath), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["srcStorageName"], "string", "srcStorageName"); err != nil {
		return nil, err
	}
	if err := typeCheckParameter(localVarOptionals["destStorageName"], "string", "destStorageName"); err != nil {
		return nil, err
	}
	if err := typeCheckParameter(localVarOptionals["versionId"], "string", "versionId"); err != nil {
		return nil, err
	}

	localVarQueryParams.Add("destPath", parameterToString(destPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["srcStorageName"].(string); localVarOk {
		localVarQueryParams.Add("srcStorageName", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["destStorageName"].(string); localVarOk {
		localVarQueryParams.Add("destStorageName", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["versionId"].(string); localVarOk {
		localVarQueryParams.Add("versionId", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	return localVarHttpResponse, err
}

/* PdfApiService Move folder
 @param srcPath Folder path to move e.g. &#39;/folder&#39;
 @param destPath Destination folder path to move to e.g &#39;/dst&#39;
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "srcStorageName" (string) Source storage name
     @param "destStorageName" (string) Destination storage name
 @return */
func (a *PdfApiService) MoveFolder(srcPath string, destPath string, localVarOptionals map[string]interface{}) ( *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/storage/folder/move/{srcPath}"
	localVarPath = strings.Replace(localVarPath, "{"+"srcPath"+"}", fmt.Sprintf("%v", srcPath), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["srcStorageName"], "string", "srcStorageName"); err != nil {
		return nil, err
	}
	if err := typeCheckParameter(localVarOptionals["destStorageName"], "string", "destStorageName"); err != nil {
		return nil, err
	}

	localVarQueryParams.Add("destPath", parameterToString(destPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["srcStorageName"].(string); localVarOk {
		localVarQueryParams.Add("srcStorageName", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["destStorageName"].(string); localVarOk {
		localVarQueryParams.Add("destStorageName", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	return localVarHttpResponse, err
}

/* PdfApiService Check if file or folder exists
 @param path File or folder path e.g. &#39;/file.ext&#39; or &#39;/folder&#39;
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storageName" (string) Storage name
     @param "versionId" (string) File version ID
 @return ObjectExist*/
func (a *PdfApiService) ObjectExists(path string, localVarOptionals map[string]interface{}) (ObjectExist,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload ObjectExist
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/storage/exist/{path}"
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", fmt.Sprintf("%v", path), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storageName"], "string", "storageName"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["versionId"], "string", "versionId"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storageName"].(string); localVarOk {
		localVarQueryParams.Add("storageName", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["versionId"].(string); localVarOk {
		localVarQueryParams.Add("versionId", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Append document to existing one.
 @param name The original document name.
 @param appendFile Append file server path.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "startPage" (int32) Appending start page.
     @param "endPage" (int32) Appending end page.
     @param "storage" (string) The documents storage.
     @param "folder" (string) The original document folder.
 @return DocumentResponse*/
func (a *PdfApiService) PostAppendDocument(name string, appendFile string, localVarOptionals map[string]interface{}) (DocumentResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload DocumentResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/appendDocument"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["startPage"], "int32", "startPage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["endPage"], "int32", "endPage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("appendFile", parameterToString(appendFile, ""))
	if localVarTempParam, localVarOk := localVarOptionals["startPage"].(int32); localVarOk {
		localVarQueryParams.Add("startPage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["endPage"].(int32); localVarOk {
		localVarQueryParams.Add("endPage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Add document bookmarks.
 @param name The document name.
 @param bookmarkPath The parent bookmark path. Specify an empty string when adding a bookmark to the root.
 @param bookmarks The array of bookmark.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
 @return BookmarksResponse*/
func (a *PdfApiService) PostBookmark(name string, bookmarkPath string, bookmarks []Bookmark, localVarOptionals map[string]interface{}) (BookmarksResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload BookmarksResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/bookmarks/bookmark/{bookmarkPath}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"bookmarkPath"+"}", fmt.Sprintf("%v", bookmarkPath), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &bookmarks
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Change document password in storage.
 @param name Document name.
 @param ownerPassword Owner password (encrypted Base64).
 @param newUserPassword New user password (encrypted Base64).
 @param newOwnerPassword New owner password (encrypted Base64).
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PostChangePasswordDocumentInStorage(name string, ownerPassword string, newUserPassword string, newOwnerPassword string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/changepassword"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("ownerPassword", parameterToString(ownerPassword, ""))
	localVarQueryParams.Add("newUserPassword", parameterToString(newUserPassword, ""))
	localVarQueryParams.Add("newOwnerPassword", parameterToString(newOwnerPassword, ""))
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Add document checkbox fields.
 @param name The document name.
 @param fields The array of field.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PostCheckBoxFields(name string, fields []CheckBoxField, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/fields/checkbox"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &fields
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Add document combobox fields.
 @param name The document name.
 @param fields The array of field.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PostComboBoxFields(name string, fields []ComboBoxField, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/fields/combobox"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &fields
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Create empty document.
 @param name The new document name.
 @param documentConfig The document config for new document.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The new document folder.
 @return DocumentResponse*/
func (a *PdfApiService) PostCreateDocument(name string, documentConfig DocumentConfig, localVarOptionals map[string]interface{}) (DocumentResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload DocumentResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &documentConfig
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Create field.
 @param name The document name.
 @param page Document page number.
 @param field Field with the field data.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PostCreateField(name string, page int32, field Field, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/fields"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("page", parameterToString(page, ""))
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &field
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Decrypt document in storage.
 @param name Document name.
 @param password The password (encrypted Base64).
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PostDecryptDocumentInStorage(name string, password string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/decrypt"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("password", parameterToString(password, ""))
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Add document image footer.
 @param name The document name.
 @param imageFooter The image footer.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "startPageNumber" (int32) The start page number.
     @param "endPageNumber" (int32) The end page number.
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PostDocumentImageFooter(name string, imageFooter ImageFooter, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/footer/image"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["startPageNumber"], "int32", "startPageNumber"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["endPageNumber"], "int32", "endPageNumber"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["startPageNumber"].(int32); localVarOk {
		localVarQueryParams.Add("startPageNumber", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["endPageNumber"].(int32); localVarOk {
		localVarQueryParams.Add("endPageNumber", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &imageFooter
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Add document image header.
 @param name The document name.
 @param imageHeader The image header.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "startPageNumber" (int32) The start page number.
     @param "endPageNumber" (int32) The end page number.
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PostDocumentImageHeader(name string, imageHeader ImageHeader, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/header/image"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["startPageNumber"], "int32", "startPageNumber"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["endPageNumber"], "int32", "endPageNumber"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["startPageNumber"].(int32); localVarOk {
		localVarQueryParams.Add("startPageNumber", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["endPageNumber"].(int32); localVarOk {
		localVarQueryParams.Add("endPageNumber", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &imageHeader
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Add document page number stamps.
 @param name The document name.
 @param stamp The stamp.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "startPageNumber" (int32) The start page number.
     @param "endPageNumber" (int32) The end page number.
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PostDocumentPageNumberStamps(name string, stamp PageNumberStamp, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/stamps/pagenumber"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["startPageNumber"], "int32", "startPageNumber"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["endPageNumber"], "int32", "endPageNumber"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["startPageNumber"].(int32); localVarOk {
		localVarQueryParams.Add("startPageNumber", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["endPageNumber"].(int32); localVarOk {
		localVarQueryParams.Add("endPageNumber", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &stamp
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Add document text footer.
 @param name The document name.
 @param textFooter The text footer.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "startPageNumber" (int32) The start page number.
     @param "endPageNumber" (int32) The end page number.
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PostDocumentTextFooter(name string, textFooter TextFooter, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/footer/text"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["startPageNumber"], "int32", "startPageNumber"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["endPageNumber"], "int32", "endPageNumber"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["startPageNumber"].(int32); localVarOk {
		localVarQueryParams.Add("startPageNumber", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["endPageNumber"].(int32); localVarOk {
		localVarQueryParams.Add("endPageNumber", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &textFooter
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Add document text header.
 @param name The document name.
 @param textHeader The text header.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "startPageNumber" (int32) The start page number.
     @param "endPageNumber" (int32) The end page number.
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PostDocumentTextHeader(name string, textHeader TextHeader, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/header/text"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["startPageNumber"], "int32", "startPageNumber"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["endPageNumber"], "int32", "endPageNumber"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["startPageNumber"].(int32); localVarOk {
		localVarQueryParams.Add("startPageNumber", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["endPageNumber"].(int32); localVarOk {
		localVarQueryParams.Add("endPageNumber", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &textHeader
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Document&#39;s replace text method.
 @param name 
 @param textReplace 
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) 
     @param "folder" (string) 
 @return TextReplaceResponse*/
func (a *PdfApiService) PostDocumentTextReplace(name string, textReplace TextReplaceListRequest, localVarOptionals map[string]interface{}) (TextReplaceResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload TextReplaceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/text/replace"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &textReplace
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Encrypt document in storage.
 @param name Document name.
 @param userPassword User password (encrypted Base64).
 @param ownerPassword Owner password (encrypted Base64).
 @param cryptoAlgorithm Cryptographic algorithm, see CryptoAlgorithm for details.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "permissionsFlags" ([]PermissionsFlags) Array of document permissions, see PermissionsFlags for details.
     @param "usePdf20" (bool) Support for revision 6 (Extension 8).
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PostEncryptDocumentInStorage(name string, userPassword string, ownerPassword string, cryptoAlgorithm string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/encrypt"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["usePdf20"], "bool", "usePdf20"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("userPassword", parameterToString(userPassword, ""))
	localVarQueryParams.Add("ownerPassword", parameterToString(ownerPassword, ""))
	localVarQueryParams.Add("cryptoAlgorithm", parameterToString(cryptoAlgorithm, ""))
	if localVarTempParam, localVarOk := localVarOptionals["permissionsFlags"].([]PermissionsFlags); localVarOk {
		localVarQueryParams.Add("permissionsFlags", parameterToString(localVarTempParam, "csv"))
	}
	if localVarTempParam, localVarOk := localVarOptionals["usePdf20"].(bool); localVarOk {
		localVarQueryParams.Add("usePdf20", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Flatten the document.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "updateAppearances" (bool) If set, all field appearances will be regenerated before flattening. This option may help if field is incorrectly flattened. This option may decrease performance..
     @param "callEvents" (bool) If set, formatting and other JavaScript events will be called.
     @param "hideButtons" (bool) If set, buttons will be removed from flattened document.
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PostFlattenDocument(name string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/flatten"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["updateAppearances"], "bool", "updateAppearances"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["callEvents"], "bool", "callEvents"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["hideButtons"], "bool", "hideButtons"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["updateAppearances"].(bool); localVarOk {
		localVarQueryParams.Add("updateAppearances", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["callEvents"].(bool); localVarOk {
		localVarQueryParams.Add("callEvents", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["hideButtons"].(bool); localVarOk {
		localVarQueryParams.Add("hideButtons", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Update fields from FDF file in request.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
     @param "fdfData" (*os.File) Fdf file.
 @return AsposeResponse*/
func (a *PdfApiService) PostImportFieldsFromFdf(name string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/import/fdf"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "multipart/form-data",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	var localVarFile (*os.File)
	if localVarTempParam, localVarOk := localVarOptionals["fdfData"].(*os.File); localVarOk {
		localVarFile = localVarTempParam
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Update fields from XFDF file in request.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
     @param "xfdfData" (*os.File) Xfdf file.
 @return AsposeResponse*/
func (a *PdfApiService) PostImportFieldsFromXfdf(name string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/import/xfdf"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "multipart/form-data",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	var localVarFile (*os.File)
	if localVarTempParam, localVarOk := localVarOptionals["xfdfData"].(*os.File); localVarOk {
		localVarFile = localVarTempParam
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Update fields from XML file in request.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
     @param "xmlData" (*os.File) Xml file.
 @return AsposeResponse*/
func (a *PdfApiService) PostImportFieldsFromXml(name string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/import/xml"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "multipart/form-data",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	var localVarFile (*os.File)
	if localVarTempParam, localVarOk := localVarOptionals["xmlData"].(*os.File); localVarOk {
		localVarFile = localVarTempParam
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Insert image to document page.
 @param name The document name.
 @param pageNumber The page number.
 @param llx Coordinate lower left X.
 @param lly Coordinate lower left Y.
 @param urx Coordinate upper right X.
 @param ury Coordinate upper right Y.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "imageFilePath" (string) Path to image file if specified. Request content is used otherwise.
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
     @param "image" (*os.File) Image file.
 @return AsposeResponse*/
func (a *PdfApiService) PostInsertImage(name string, pageNumber int32, llx float64, lly float64, urx float64, ury float64, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/images"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["imageFilePath"], "string", "imageFilePath"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("llx", parameterToString(llx, ""))
	localVarQueryParams.Add("lly", parameterToString(lly, ""))
	localVarQueryParams.Add("urx", parameterToString(urx, ""))
	localVarQueryParams.Add("ury", parameterToString(ury, ""))
	if localVarTempParam, localVarOk := localVarOptionals["imageFilePath"].(string); localVarOk {
		localVarQueryParams.Add("imageFilePath", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "multipart/form-data",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	var localVarFile (*os.File)
	if localVarTempParam, localVarOk := localVarOptionals["image"].(*os.File); localVarOk {
		localVarFile = localVarTempParam
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Add document listbox fields.
 @param name The document name.
 @param fields The array of field.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PostListBoxFields(name string, fields []ListBoxField, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/fields/listbox"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &fields
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Move page to new position.
 @param name The document name.
 @param pageNumber The page number.
 @param newIndex The new page position/index.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PostMovePage(name string, pageNumber int32, newIndex int32, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/movePage"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("newIndex", parameterToString(newIndex, ""))
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Optimize document.
 @param name The document name.
 @param options The optimization options.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PostOptimizeDocument(name string, options OptimizeOptions, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/optimize"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &options
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Merge selected pages of a document.
 @param name The original document name.
 @param pages 1-based page numbers of the source document that make up the resulting document.
 @param outPath Full filename of the resulting document.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The documents storage.
     @param "folder" (string) The source document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PostOrganizeDocument(name string, pages string, outPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/organize"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if strlen(pages) < 1 {
		return successPayload, nil, reportError("pages must have at least 1 elements")
	}
	if strlen(outPath) < 1 {
		return successPayload, nil, reportError("outPath must have at least 1 elements")
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("pages", parameterToString(pages, ""))
	localVarQueryParams.Add("outPath", parameterToString(outPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Merge selected pages of different documents.
 @param organizeDocuments Array of OrganizeDocumentData to make up the resulting document.
 @param outPath Full filename of the resulting document.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The documents storage.
 @return AsposeResponse*/
func (a *PdfApiService) PostOrganizeDocuments(organizeDocuments OrganizeDocumentRequest, outPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/organize"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if strlen(outPath) < 1 {
		return successPayload, nil, reportError("outPath must have at least 1 elements")
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("outPath", parameterToString(outPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &organizeDocuments
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Add document page caret annotations.
 @param name The document name.
 @param pageNumber The page number.
 @param annotations The array of annotation.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PostPageCaretAnnotations(name string, pageNumber int32, annotations []CaretAnnotation, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/annotations/caret"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &annotations
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Certify document page.
 @param name The document name.
 @param pageNumber The page number.
 @param sign Signature object containing signature data.
 @param docMdpAccessPermissionType The access permissions granted for this document.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PostPageCertify(name string, pageNumber int32, sign Signature, docMdpAccessPermissionType string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/certify"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("docMdpAccessPermissionType", parameterToString(docMdpAccessPermissionType, ""))
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &sign
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Add document page circle annotations.
 @param name The document name.
 @param pageNumber The page number.
 @param annotations The array of annotation.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PostPageCircleAnnotations(name string, pageNumber int32, annotations []CircleAnnotation, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/annotations/circle"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &annotations
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Add document page FileAttachment annotations.
 @param name The document name.
 @param pageNumber The page number.
 @param annotations Annotation.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PostPageFileAttachmentAnnotations(name string, pageNumber int32, annotations []FileAttachmentAnnotation, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/annotations/fileattachment"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &annotations
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Add document page free text annotations.
 @param name The document name.
 @param pageNumber The page number.
 @param annotations The array of annotation.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PostPageFreeTextAnnotations(name string, pageNumber int32, annotations []FreeTextAnnotation, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/annotations/freetext"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &annotations
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Add document page highlight annotations.
 @param name The document name.
 @param pageNumber The page number.
 @param annotations The array of annotation.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PostPageHighlightAnnotations(name string, pageNumber int32, annotations []HighlightAnnotation, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/annotations/highlight"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &annotations
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Add document page image stamps.
 @param name The document name.
 @param pageNumber The page number.
 @param stamps The array of stamp.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PostPageImageStamps(name string, pageNumber int32, stamps []ImageStamp, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/stamps/image"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &stamps
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Add document page ink annotations.
 @param name The document name.
 @param pageNumber The page number.
 @param annotations The array of annotation.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PostPageInkAnnotations(name string, pageNumber int32, annotations []InkAnnotation, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/annotations/ink"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &annotations
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Add document page line annotations.
 @param name The document name.
 @param pageNumber The page number.
 @param annotations The array of annotation.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PostPageLineAnnotations(name string, pageNumber int32, annotations []LineAnnotation, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/annotations/line"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &annotations
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Add document page link annotations.
 @param name The document name.
 @param pageNumber The page number.
 @param links Array of link annotation.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PostPageLinkAnnotations(name string, pageNumber int32, links []LinkAnnotation, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/links"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &links
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Add document page movie annotations.
 @param name The document name.
 @param pageNumber The page number.
 @param annotations The array of annotation.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PostPageMovieAnnotations(name string, pageNumber int32, annotations []MovieAnnotation, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/annotations/movie"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &annotations
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Add document pdf page stamps.
 @param name The document name.
 @param pageNumber The page number.
 @param stamps The array of stamp.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PostPagePdfPageStamps(name string, pageNumber int32, stamps []PdfPageStamp, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/stamps/pdfpage"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &stamps
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Add document page polyline annotations.
 @param name The document name.
 @param pageNumber The page number.
 @param annotations The array of annotation.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PostPagePolyLineAnnotations(name string, pageNumber int32, annotations []PolyLineAnnotation, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/annotations/polyline"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &annotations
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Add document page polygon annotations.
 @param name The document name.
 @param pageNumber The page number.
 @param annotations The array of annotation.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PostPagePolygonAnnotations(name string, pageNumber int32, annotations []PolygonAnnotation, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/annotations/polygon"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &annotations
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Add document page redaction annotations.
 @param name The document name.
 @param pageNumber The page number.
 @param annotations The array of annotation.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
     @param "apply" (bool) Apply redaction immediately after adding.
 @return AsposeResponse*/
func (a *PdfApiService) PostPageRedactionAnnotations(name string, pageNumber int32, annotations []RedactionAnnotation, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/annotations/redaction"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["apply"], "bool", "apply"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["apply"].(bool); localVarOk {
		localVarQueryParams.Add("apply", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &annotations
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Add document page screen annotations.
 @param name The document name.
 @param pageNumber The page number.
 @param annotations The array of annotation.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PostPageScreenAnnotations(name string, pageNumber int32, annotations []ScreenAnnotation, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/annotations/screen"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &annotations
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Add document page sound annotations.
 @param name The document name.
 @param pageNumber The page number.
 @param annotations The array of annotation.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PostPageSoundAnnotations(name string, pageNumber int32, annotations []SoundAnnotation, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/annotations/sound"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &annotations
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Add document page square annotations.
 @param name The document name.
 @param pageNumber The page number.
 @param annotations The array of annotation.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PostPageSquareAnnotations(name string, pageNumber int32, annotations []SquareAnnotation, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/annotations/square"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &annotations
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Add document page squiggly annotations.
 @param name The document name.
 @param pageNumber The page number.
 @param annotations The array of annotation.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PostPageSquigglyAnnotations(name string, pageNumber int32, annotations []SquigglyAnnotation, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/annotations/squiggly"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &annotations
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Add document page stamp annotations.
 @param name The document name.
 @param pageNumber The page number.
 @param annotations The array of annotation.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PostPageStampAnnotations(name string, pageNumber int32, annotations []StampAnnotation, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/annotations/stamp"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &annotations
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Add document page StrikeOut annotations.
 @param name The document name.
 @param pageNumber The page number.
 @param annotations The array of annotation.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PostPageStrikeOutAnnotations(name string, pageNumber int32, annotations []StrikeOutAnnotation, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/annotations/strikeout"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &annotations
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Add document page tables.
 @param name The document name.
 @param pageNumber The page number.
 @param tables The array of table.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PostPageTables(name string, pageNumber int32, tables []Table, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/tables"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &tables
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Add document page text annotations.
 @param name The document name.
 @param pageNumber The page number.
 @param annotations The array of annotation.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PostPageTextAnnotations(name string, pageNumber int32, annotations []TextAnnotation, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/annotations/text"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &annotations
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Page&#39;s replace text method.
 @param name 
 @param pageNumber 
 @param textReplaceListRequest 
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) 
     @param "folder" (string) 
 @return TextReplaceResponse*/
func (a *PdfApiService) PostPageTextReplace(name string, pageNumber int32, textReplaceListRequest TextReplaceListRequest, localVarOptionals map[string]interface{}) (TextReplaceResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload TextReplaceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/text/replace"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &textReplaceListRequest
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Add document page text stamps.
 @param name The document name.
 @param pageNumber The page number.
 @param stamps The array of stamp.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PostPageTextStamps(name string, pageNumber int32, stamps []TextStamp, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/stamps/text"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &stamps
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Add document page underline annotations.
 @param name The document name.
 @param pageNumber The page number.
 @param annotations The array of annotation.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PostPageUnderlineAnnotations(name string, pageNumber int32, annotations []UnderlineAnnotation, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/annotations/underline"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &annotations
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Add document popup annotations.
 @param name The document name.
 @param annotationId The parent annotation ID.
 @param annotation The annotation.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PostPopupAnnotation(name string, annotationId string, annotation PopupAnnotation, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/{annotationId}/popup"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &annotation
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Add document RadioButton fields.
 @param name The document name.
 @param fields The array of field.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PostRadioButtonFields(name string, fields []RadioButtonField, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/fields/radiobutton"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &fields
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Sign document.
 @param name The document name.
 @param sign Signature object containing signature data.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PostSignDocument(name string, sign Signature, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/sign"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &sign
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Sign page.
 @param name The document name.
 @param pageNumber The page number.
 @param sign Signature object containing signature data.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PostSignPage(name string, pageNumber int32, sign Signature, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/sign"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &sign
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Add document signature field.
 @param name The document name.
 @param field The field.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PostSignatureField(name string, field SignatureField, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/fields/signature"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &field
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Split document to parts.
 @param name Document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "format" (string) Resulting documents format.
     @param "from" (int32) Start page if defined.
     @param "to" (int32) End page if defined.
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
     @param "password" (string) Base64 encoded password.
 @return SplitResultResponse*/
func (a *PdfApiService) PostSplitDocument(name string, localVarOptionals map[string]interface{}) (SplitResultResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload SplitResultResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/split"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["format"], "string", "format"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["from"], "int32", "from"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["to"], "int32", "to"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["password"], "string", "password"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["format"].(string); localVarOk {
		localVarQueryParams.Add("format", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["from"].(int32); localVarOk {
		localVarQueryParams.Add("from", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["to"].(int32); localVarOk {
		localVarQueryParams.Add("to", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["password"].(string); localVarOk {
		localVarQueryParams.Add("password", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Split document into ranges.
 @param name The document name.
 @param options The splitting options.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
     @param "password" (string) Base64 encoded password.
 @return SplitResultResponse*/
func (a *PdfApiService) PostSplitRangePdfDocument(name string, options SplitRangePdfOptions, localVarOptionals map[string]interface{}) (SplitResultResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload SplitResultResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/splitrangepdf"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["password"], "string", "password"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["password"].(string); localVarOk {
		localVarQueryParams.Add("password", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &options
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Add document text box fields.
 @param name The document name.
 @param fields The array of field.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PostTextBoxFields(name string, fields []TextBoxField, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/fields/textbox"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &fields
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Add new page to end of the document.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return DocumentPagesResponse*/
func (a *PdfApiService) PutAddNewPage(name string, localVarOptionals map[string]interface{}) (DocumentPagesResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload DocumentPagesResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Add text to PDF document page.
 @param name The document name.
 @param pageNumber Number of page (starting from 1).
 @param paragraph Paragraph data.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "folder" (string) Document folder.
     @param "storage" (string) The document storage.
 @return AsposeResponse*/
func (a *PdfApiService) PutAddText(name string, pageNumber int32, paragraph Paragraph, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/text"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &paragraph
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Flattens the annotations of the specified types
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "startPage" (int32) The start page number.
     @param "endPage" (int32) The end page number.
     @param "annotationTypes" ([]AnnotationType) Array of annotation types.
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PutAnnotationsFlatten(name string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/flatten"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["startPage"], "int32", "startPage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["endPage"], "int32", "endPage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["startPage"].(int32); localVarOk {
		localVarQueryParams.Add("startPage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["endPage"].(int32); localVarOk {
		localVarQueryParams.Add("endPage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["annotationTypes"].([]AnnotationType); localVarOk {
		localVarQueryParams.Add("annotationTypes", parameterToString(localVarTempParam, "csv"))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Update document bookmark.
 @param name The document name.
 @param bookmarkPath The bookmark path.
 @param bookmark The bookmark.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
 @return BookmarkResponse*/
func (a *PdfApiService) PutBookmark(name string, bookmarkPath string, bookmark Bookmark, localVarOptionals map[string]interface{}) (BookmarkResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload BookmarkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/bookmarks/bookmark/{bookmarkPath}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"bookmarkPath"+"}", fmt.Sprintf("%v", bookmarkPath), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &bookmark
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Replace document caret annotation
 @param name The document name.
 @param annotationId The annotation ID.
 @param annotation Annotation.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return CaretAnnotationResponse*/
func (a *PdfApiService) PutCaretAnnotation(name string, annotationId string, annotation CaretAnnotation, localVarOptionals map[string]interface{}) (CaretAnnotationResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload CaretAnnotationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/caret/{annotationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &annotation
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Change document password from content.
 @param outPath Full resulting filename (ex. /folder1/folder2/result.doc)
 @param ownerPassword Owner password (encrypted Base64).
 @param newUserPassword New user password (encrypted Base64).
 @param newOwnerPassword New owner password (encrypted Base64).
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "file" (*os.File) A file to be changed password.
 @return AsposeResponse*/
func (a *PdfApiService) PutChangePasswordDocument(outPath string, ownerPassword string, newUserPassword string, newOwnerPassword string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/changepassword"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("outPath", parameterToString(outPath, ""))
	localVarQueryParams.Add("ownerPassword", parameterToString(ownerPassword, ""))
	localVarQueryParams.Add("newUserPassword", parameterToString(newUserPassword, ""))
	localVarQueryParams.Add("newOwnerPassword", parameterToString(newOwnerPassword, ""))
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "multipart/form-data",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	var localVarFile (*os.File)
	if localVarTempParam, localVarOk := localVarOptionals["file"].(*os.File); localVarOk {
		localVarFile = localVarTempParam
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Replace document checkbox field
 @param name The document name.
 @param fieldName The field name.
 @param field The field.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return CheckBoxFieldResponse*/
func (a *PdfApiService) PutCheckBoxField(name string, fieldName string, field CheckBoxField, localVarOptionals map[string]interface{}) (CheckBoxFieldResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload CheckBoxFieldResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/fields/checkbox/{fieldName}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fieldName"+"}", fmt.Sprintf("%v", fieldName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &field
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Replace document circle annotation
 @param name The document name.
 @param annotationId The annotation ID.
 @param annotation Annotation.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return CircleAnnotationResponse*/
func (a *PdfApiService) PutCircleAnnotation(name string, annotationId string, annotation CircleAnnotation, localVarOptionals map[string]interface{}) (CircleAnnotationResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload CircleAnnotationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/circle/{annotationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &annotation
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Replace document combobox field
 @param name The document name.
 @param fieldName The field name.
 @param field The field.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return ComboBoxFieldResponse*/
func (a *PdfApiService) PutComboBoxField(name string, fieldName string, field ComboBoxField, localVarOptionals map[string]interface{}) (ComboBoxFieldResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload ComboBoxFieldResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/fields/combobox/{fieldName}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fieldName"+"}", fmt.Sprintf("%v", fieldName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &field
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Create empty document.
 @param name The new document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The new document folder.
 @return DocumentResponse*/
func (a *PdfApiService) PutCreateDocument(name string, localVarOptionals map[string]interface{}) (DocumentResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload DocumentResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Decrypt document from content.
 @param outPath Full resulting filename (ex. /folder1/folder2/result.doc)
 @param password The password (encrypted Base64).
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "file" (*os.File) A file to be decrypted.
 @return AsposeResponse*/
func (a *PdfApiService) PutDecryptDocument(outPath string, password string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/decrypt"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("outPath", parameterToString(outPath, ""))
	localVarQueryParams.Add("password", parameterToString(password, ""))
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "multipart/form-data",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	var localVarFile (*os.File)
	if localVarTempParam, localVarOk := localVarOptionals["file"].(*os.File); localVarOk {
		localVarFile = localVarTempParam
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Update document display properties.
 @param name The document name.
 @param displayProperties The display properties.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return DisplayPropertiesResponse*/
func (a *PdfApiService) PutDocumentDisplayProperties(name string, displayProperties DisplayProperties, localVarOptionals map[string]interface{}) (DisplayPropertiesResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload DisplayPropertiesResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/displayproperties"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &displayProperties
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Encrypt document from content.
 @param outPath Full resulting filename (ex. /folder1/folder2/result.doc)
 @param userPassword User password (encrypted Base64).
 @param ownerPassword Owner password (encrypted Base64).
 @param cryptoAlgorithm Cryptographic algorithm, see CryptoAlgorithm for details.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "permissionsFlags" ([]PermissionsFlags) Array of document permissions, see PermissionsFlags for details.
     @param "usePdf20" (bool) Support for revision 6 (Extension 8).
     @param "storage" (string) The document storage.
     @param "file" (*os.File) A file to be encrypted.
 @return AsposeResponse*/
func (a *PdfApiService) PutEncryptDocument(outPath string, userPassword string, ownerPassword string, cryptoAlgorithm string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/encrypt"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["usePdf20"], "bool", "usePdf20"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("outPath", parameterToString(outPath, ""))
	localVarQueryParams.Add("userPassword", parameterToString(userPassword, ""))
	localVarQueryParams.Add("ownerPassword", parameterToString(ownerPassword, ""))
	localVarQueryParams.Add("cryptoAlgorithm", parameterToString(cryptoAlgorithm, ""))
	if localVarTempParam, localVarOk := localVarOptionals["permissionsFlags"].([]PermissionsFlags); localVarOk {
		localVarQueryParams.Add("permissionsFlags", parameterToString(localVarTempParam, "csv"))
	}
	if localVarTempParam, localVarOk := localVarOptionals["usePdf20"].(bool); localVarOk {
		localVarQueryParams.Add("usePdf20", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "multipart/form-data",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	var localVarFile (*os.File)
	if localVarTempParam, localVarOk := localVarOptionals["file"].(*os.File); localVarOk {
		localVarFile = localVarTempParam
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Convert EPUB file (located on storage) to PDF format and upload resulting file to storage. 
 @param name The document name.
 @param srcPath Full source filename (ex. /folder1/folder2/template.epub)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "dstFolder" (string) The destination document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PutEpubInStorageToPdf(name string, srcPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/create/epub"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["dstFolder"], "string", "dstFolder"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("srcPath", parameterToString(srcPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["dstFolder"].(string); localVarOk {
		localVarQueryParams.Add("dstFolder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Export fields from from PDF in storage to FDF file in storage.
 @param name The document name.
 @param fdfOutputFilePath The output Fdf file path.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PutExportFieldsFromPdfToFdfInStorage(name string, fdfOutputFilePath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/export/fdf"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("fdfOutputFilePath", parameterToString(fdfOutputFilePath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Export fields from from PDF in storage to XFDF file in storage.
 @param name The document name.
 @param xfdfOutputFilePath The output xfdf file path.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PutExportFieldsFromPdfToXfdfInStorage(name string, xfdfOutputFilePath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/export/xfdf"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("xfdfOutputFilePath", parameterToString(xfdfOutputFilePath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Export fields from from PDF in storage to XML file in storage.
 @param name The document name.
 @param xmlOutputFilePath The output xml file path.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PutExportFieldsFromPdfToXmlInStorage(name string, xmlOutputFilePath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/export/xml"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("xmlOutputFilePath", parameterToString(xmlOutputFilePath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Flatten form fields in document.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PutFieldsFlatten(name string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/fields/flatten"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Replace document FileAttachment annotation
 @param name The document name.
 @param annotationId The annotation ID.
 @param annotation Annotation.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return FileAttachmentAnnotationResponse*/
func (a *PdfApiService) PutFileAttachmentAnnotation(name string, annotationId string, annotation FileAttachmentAnnotation, localVarOptionals map[string]interface{}) (FileAttachmentAnnotationResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload FileAttachmentAnnotationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/fileattachment/{annotationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &annotation
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Extract document FileAttachment annotation content to storage
 @param name The document name.
 @param annotationId The annotation ID.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "outFolder" (string) The output folder.
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PutFileAttachmentAnnotationDataExtract(name string, annotationId string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/fileattachment/{annotationId}/data/extract"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["outFolder"], "string", "outFolder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["outFolder"].(string); localVarOk {
		localVarQueryParams.Add("outFolder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Replace document free text annotation
 @param name The document name.
 @param annotationId The annotation ID.
 @param annotation Annotation.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return FreeTextAnnotationResponse*/
func (a *PdfApiService) PutFreeTextAnnotation(name string, annotationId string, annotation FreeTextAnnotation, localVarOptionals map[string]interface{}) (FreeTextAnnotationResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload FreeTextAnnotationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/freetext/{annotationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &annotation
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Replace document highlight annotation
 @param name The document name.
 @param annotationId The annotation ID.
 @param annotation Annotation.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return HighlightAnnotationResponse*/
func (a *PdfApiService) PutHighlightAnnotation(name string, annotationId string, annotation HighlightAnnotation, localVarOptionals map[string]interface{}) (HighlightAnnotationResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload HighlightAnnotationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/highlight/{annotationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &annotation
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Convert HTML file (located on storage) to PDF format and upload resulting file to storage. 
 @param name The document name.
 @param srcPath Full source filename (ex. /folder1/folder2/template.zip)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "htmlFileName" (string) Name of HTML file in ZIP.
     @param "height" (float64) Page height
     @param "width" (float64) Page width
     @param "isLandscape" (bool) Is page landscaped
     @param "marginLeft" (float64) Page margin left
     @param "marginBottom" (float64) Page margin bottom
     @param "marginRight" (float64) Page margin right
     @param "marginTop" (float64) Page margin top
     @param "dstFolder" (string) The destination document folder.
     @param "storage" (string) The document storage.
 @return AsposeResponse*/
func (a *PdfApiService) PutHtmlInStorageToPdf(name string, srcPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/create/html"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["htmlFileName"], "string", "htmlFileName"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["height"], "float64", "height"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["width"], "float64", "width"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["isLandscape"], "bool", "isLandscape"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["marginLeft"], "float64", "marginLeft"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["marginBottom"], "float64", "marginBottom"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["marginRight"], "float64", "marginRight"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["marginTop"], "float64", "marginTop"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["dstFolder"], "string", "dstFolder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("srcPath", parameterToString(srcPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["htmlFileName"].(string); localVarOk {
		localVarQueryParams.Add("htmlFileName", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["height"].(float64); localVarOk {
		localVarQueryParams.Add("height", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["width"].(float64); localVarOk {
		localVarQueryParams.Add("width", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["isLandscape"].(bool); localVarOk {
		localVarQueryParams.Add("isLandscape", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["marginLeft"].(float64); localVarOk {
		localVarQueryParams.Add("marginLeft", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["marginBottom"].(float64); localVarOk {
		localVarQueryParams.Add("marginBottom", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["marginRight"].(float64); localVarOk {
		localVarQueryParams.Add("marginRight", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["marginTop"].(float64); localVarOk {
		localVarQueryParams.Add("marginTop", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["dstFolder"].(string); localVarOk {
		localVarQueryParams.Add("dstFolder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Extract document image in GIF format to folder
 @param name The document name.
 @param imageId Image ID.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "width" (int32) The converted image width.
     @param "height" (int32) The converted image height.
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
     @param "destFolder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PutImageExtractAsGif(name string, imageId string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/images/{imageId}/extract/gif"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageId"+"}", fmt.Sprintf("%v", imageId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["width"], "int32", "width"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["height"], "int32", "height"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["destFolder"], "string", "destFolder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["width"].(int32); localVarOk {
		localVarQueryParams.Add("width", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["height"].(int32); localVarOk {
		localVarQueryParams.Add("height", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["destFolder"].(string); localVarOk {
		localVarQueryParams.Add("destFolder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Extract document image in JPEG format to folder
 @param name The document name.
 @param imageId Image ID.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "width" (int32) The converted image width.
     @param "height" (int32) The converted image height.
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
     @param "destFolder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PutImageExtractAsJpeg(name string, imageId string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/images/{imageId}/extract/jpeg"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageId"+"}", fmt.Sprintf("%v", imageId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["width"], "int32", "width"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["height"], "int32", "height"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["destFolder"], "string", "destFolder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["width"].(int32); localVarOk {
		localVarQueryParams.Add("width", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["height"].(int32); localVarOk {
		localVarQueryParams.Add("height", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["destFolder"].(string); localVarOk {
		localVarQueryParams.Add("destFolder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Extract document image in PNG format to folder
 @param name The document name.
 @param imageId Image ID.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "width" (int32) The converted image width.
     @param "height" (int32) The converted image height.
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
     @param "destFolder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PutImageExtractAsPng(name string, imageId string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/images/{imageId}/extract/png"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageId"+"}", fmt.Sprintf("%v", imageId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["width"], "int32", "width"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["height"], "int32", "height"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["destFolder"], "string", "destFolder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["width"].(int32); localVarOk {
		localVarQueryParams.Add("width", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["height"].(int32); localVarOk {
		localVarQueryParams.Add("height", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["destFolder"].(string); localVarOk {
		localVarQueryParams.Add("destFolder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Extract document image in TIFF format to folder
 @param name The document name.
 @param imageId Image ID.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "width" (int32) The converted image width.
     @param "height" (int32) The converted image height.
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
     @param "destFolder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PutImageExtractAsTiff(name string, imageId string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/images/{imageId}/extract/tiff"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageId"+"}", fmt.Sprintf("%v", imageId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["width"], "int32", "width"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["height"], "int32", "height"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["destFolder"], "string", "destFolder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["width"].(int32); localVarOk {
		localVarQueryParams.Add("width", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["height"].(int32); localVarOk {
		localVarQueryParams.Add("height", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["destFolder"].(string); localVarOk {
		localVarQueryParams.Add("destFolder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Convert image file (located on storage) to PDF format and upload resulting file to storage. 
 @param name The document name.
 @param imageTemplates ImageTemplatesRequestImage templates
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "dstFolder" (string) The destination document folder.
     @param "storage" (string) The document storage.
 @return AsposeResponse*/
func (a *PdfApiService) PutImageInStorageToPdf(name string, imageTemplates ImageTemplatesRequest, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/create/images"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["dstFolder"], "string", "dstFolder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["dstFolder"].(string); localVarOk {
		localVarQueryParams.Add("dstFolder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &imageTemplates
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Extract document images in GIF format to folder.
 @param name The document name.
 @param pageNumber The page number.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "width" (int32) The converted image width.
     @param "height" (int32) The converted image height.
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
     @param "destFolder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PutImagesExtractAsGif(name string, pageNumber int32, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/images/extract/gif"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["width"], "int32", "width"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["height"], "int32", "height"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["destFolder"], "string", "destFolder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["width"].(int32); localVarOk {
		localVarQueryParams.Add("width", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["height"].(int32); localVarOk {
		localVarQueryParams.Add("height", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["destFolder"].(string); localVarOk {
		localVarQueryParams.Add("destFolder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Extract document images in JPEG format to folder.
 @param name The document name.
 @param pageNumber The page number.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "width" (int32) The converted image width.
     @param "height" (int32) The converted image height.
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
     @param "destFolder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PutImagesExtractAsJpeg(name string, pageNumber int32, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/images/extract/jpeg"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["width"], "int32", "width"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["height"], "int32", "height"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["destFolder"], "string", "destFolder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["width"].(int32); localVarOk {
		localVarQueryParams.Add("width", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["height"].(int32); localVarOk {
		localVarQueryParams.Add("height", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["destFolder"].(string); localVarOk {
		localVarQueryParams.Add("destFolder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Extract document images in PNG format to folder.
 @param name The document name.
 @param pageNumber The page number.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "width" (int32) The converted image width.
     @param "height" (int32) The converted image height.
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
     @param "destFolder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PutImagesExtractAsPng(name string, pageNumber int32, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/images/extract/png"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["width"], "int32", "width"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["height"], "int32", "height"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["destFolder"], "string", "destFolder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["width"].(int32); localVarOk {
		localVarQueryParams.Add("width", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["height"].(int32); localVarOk {
		localVarQueryParams.Add("height", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["destFolder"].(string); localVarOk {
		localVarQueryParams.Add("destFolder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Extract document images in TIFF format to folder.
 @param name The document name.
 @param pageNumber The page number.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "width" (int32) The converted image width.
     @param "height" (int32) The converted image height.
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
     @param "destFolder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PutImagesExtractAsTiff(name string, pageNumber int32, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/images/extract/tiff"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["width"], "int32", "width"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["height"], "int32", "height"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["destFolder"], "string", "destFolder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["width"].(int32); localVarOk {
		localVarQueryParams.Add("width", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["height"].(int32); localVarOk {
		localVarQueryParams.Add("height", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["destFolder"].(string); localVarOk {
		localVarQueryParams.Add("destFolder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Update fields from FDF file in storage.
 @param name The document name.
 @param fdfFilePath The Fdf file path.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PutImportFieldsFromFdfInStorage(name string, fdfFilePath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/import/fdf"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("fdfFilePath", parameterToString(fdfFilePath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Update fields from XFDF file in storage.
 @param name The document name.
 @param xfdfFilePath The XFDF file path.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PutImportFieldsFromXfdfInStorage(name string, xfdfFilePath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/import/xfdf"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("xfdfFilePath", parameterToString(xfdfFilePath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Update fields from XML file in storage.
 @param name The document name.
 @param xmlFilePath Full source filename (ex. /folder1/folder2/template.xml)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PutImportFieldsFromXmlInStorage(name string, xmlFilePath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/import/xml"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("xmlFilePath", parameterToString(xmlFilePath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Replace document ink annotation
 @param name The document name.
 @param annotationId The annotation ID.
 @param annotation Annotation.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return InkAnnotationResponse*/
func (a *PdfApiService) PutInkAnnotation(name string, annotationId string, annotation InkAnnotation, localVarOptionals map[string]interface{}) (InkAnnotationResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload InkAnnotationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/ink/{annotationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &annotation
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Replace document line annotation
 @param name The document name.
 @param annotationId The annotation ID.
 @param annotation Annotation.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return LineAnnotationResponse*/
func (a *PdfApiService) PutLineAnnotation(name string, annotationId string, annotation LineAnnotation, localVarOptionals map[string]interface{}) (LineAnnotationResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload LineAnnotationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/line/{annotationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &annotation
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Replace document page link annotations
 @param name The document name.
 @param linkId The link ID.
 @param link Link annotation.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return LinkAnnotationResponse*/
func (a *PdfApiService) PutLinkAnnotation(name string, linkId string, link LinkAnnotation, localVarOptionals map[string]interface{}) (LinkAnnotationResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload LinkAnnotationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/links/{linkId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"linkId"+"}", fmt.Sprintf("%v", linkId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &link
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Replace document listbox field
 @param name The document name.
 @param fieldName The field name.
 @param field The field.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return ListBoxFieldResponse*/
func (a *PdfApiService) PutListBoxField(name string, fieldName string, field ListBoxField, localVarOptionals map[string]interface{}) (ListBoxFieldResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload ListBoxFieldResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/fields/listbox/{fieldName}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fieldName"+"}", fmt.Sprintf("%v", fieldName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &field
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Convert MD file (located on storage) to PDF format and upload resulting file to storage. 
 @param name The document name.
 @param srcPath Full source filename (ex. /folder1/folder2/template.md)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "dstFolder" (string) The destination document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PutMarkdownInStorageToPdf(name string, srcPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/create/markdown"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["dstFolder"], "string", "dstFolder"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("srcPath", parameterToString(srcPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["dstFolder"].(string); localVarOk {
		localVarQueryParams.Add("dstFolder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Merge a list of documents.
 @param name Resulting document name.
 @param mergeDocuments MergeDocuments with a list of documents.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) Resulting document storage.
     @param "folder" (string) Resulting document folder.
 @return DocumentResponse*/
func (a *PdfApiService) PutMergeDocuments(name string, mergeDocuments MergeDocuments, localVarOptionals map[string]interface{}) (DocumentResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload DocumentResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/merge"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &mergeDocuments
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Convert MHT file (located on storage) to PDF format and upload resulting file to storage. 
 @param name The document name.
 @param srcPath Full source filename (ex. /folder1/folder2/template.mht)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "dstFolder" (string) The destination document folder.
     @param "storage" (string) The document storage.
 @return AsposeResponse*/
func (a *PdfApiService) PutMhtInStorageToPdf(name string, srcPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/create/mht"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["dstFolder"], "string", "dstFolder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("srcPath", parameterToString(srcPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["dstFolder"].(string); localVarOk {
		localVarQueryParams.Add("dstFolder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Replace document movie annotation
 @param name The document name.
 @param annotationId The annotation ID.
 @param annotation Annotation.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return MovieAnnotationResponse*/
func (a *PdfApiService) PutMovieAnnotation(name string, annotationId string, annotation MovieAnnotation, localVarOptionals map[string]interface{}) (MovieAnnotationResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload MovieAnnotationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/movie/{annotationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &annotation
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Add page stamp.
 @param name The document name.
 @param pageNumber The page number.
 @param stamp Stamp with data.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PutPageAddStamp(name string, pageNumber int32, stamp Stamp, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/stamp"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &stamp
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Convert document page to bmp image and upload resulting file to storage.
 @param name The document name.
 @param pageNumber The page number.
 @param outPath The out path of result image.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "width" (int32) The converted image width.
     @param "height" (int32) The converted image height.
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
     @param "password" (string) The password (Base64).
 @return AsposeResponse*/
func (a *PdfApiService) PutPageConvertToBmp(name string, pageNumber int32, outPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/convert/bmp"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["width"], "int32", "width"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["height"], "int32", "height"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["password"], "string", "password"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("outPath", parameterToString(outPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["width"].(int32); localVarOk {
		localVarQueryParams.Add("width", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["height"].(int32); localVarOk {
		localVarQueryParams.Add("height", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["password"].(string); localVarOk {
		localVarQueryParams.Add("password", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Convert document page to emf image and upload resulting file to storage.
 @param name The document name.
 @param pageNumber The page number.
 @param outPath The out path of result image.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "width" (int32) The converted image width.
     @param "height" (int32) The converted image height.
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
     @param "password" (string) The password (Base64).
 @return AsposeResponse*/
func (a *PdfApiService) PutPageConvertToEmf(name string, pageNumber int32, outPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/convert/emf"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["width"], "int32", "width"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["height"], "int32", "height"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["password"], "string", "password"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("outPath", parameterToString(outPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["width"].(int32); localVarOk {
		localVarQueryParams.Add("width", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["height"].(int32); localVarOk {
		localVarQueryParams.Add("height", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["password"].(string); localVarOk {
		localVarQueryParams.Add("password", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Convert document page to gif image and upload resulting file to storage.
 @param name The document name.
 @param pageNumber The page number.
 @param outPath The out path of result image.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "width" (int32) The converted image width.
     @param "height" (int32) The converted image height.
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
     @param "password" (string) The password (Base64).
 @return AsposeResponse*/
func (a *PdfApiService) PutPageConvertToGif(name string, pageNumber int32, outPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/convert/gif"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["width"], "int32", "width"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["height"], "int32", "height"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["password"], "string", "password"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("outPath", parameterToString(outPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["width"].(int32); localVarOk {
		localVarQueryParams.Add("width", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["height"].(int32); localVarOk {
		localVarQueryParams.Add("height", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["password"].(string); localVarOk {
		localVarQueryParams.Add("password", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Convert document page to Jpeg image and upload resulting file to storage.
 @param name The document name.
 @param pageNumber The page number.
 @param outPath The out path of result image.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "width" (int32) The converted image width.
     @param "height" (int32) The converted image height.
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
     @param "password" (string) The password (Base64).
 @return AsposeResponse*/
func (a *PdfApiService) PutPageConvertToJpeg(name string, pageNumber int32, outPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/convert/jpeg"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["width"], "int32", "width"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["height"], "int32", "height"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["password"], "string", "password"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("outPath", parameterToString(outPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["width"].(int32); localVarOk {
		localVarQueryParams.Add("width", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["height"].(int32); localVarOk {
		localVarQueryParams.Add("height", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["password"].(string); localVarOk {
		localVarQueryParams.Add("password", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Convert document page to png image and upload resulting file to storage.
 @param name The document name.
 @param pageNumber The page number.
 @param outPath The out path of result image.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "width" (int32) The converted image width.
     @param "height" (int32) The converted image height.
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
     @param "password" (string) The password (Base64).
 @return AsposeResponse*/
func (a *PdfApiService) PutPageConvertToPng(name string, pageNumber int32, outPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/convert/png"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["width"], "int32", "width"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["height"], "int32", "height"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["password"], "string", "password"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("outPath", parameterToString(outPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["width"].(int32); localVarOk {
		localVarQueryParams.Add("width", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["height"].(int32); localVarOk {
		localVarQueryParams.Add("height", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["password"].(string); localVarOk {
		localVarQueryParams.Add("password", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Convert document page to Tiff image and upload resulting file to storage.
 @param name The document name.
 @param pageNumber The page number.
 @param outPath The out path of result image.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "width" (int32) The converted image width.
     @param "height" (int32) The converted image height.
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
     @param "password" (string) The password (Base64).
 @return AsposeResponse*/
func (a *PdfApiService) PutPageConvertToTiff(name string, pageNumber int32, outPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/pages/{pageNumber}/convert/tiff"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", fmt.Sprintf("%v", pageNumber), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["width"], "int32", "width"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["height"], "int32", "height"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["password"], "string", "password"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("outPath", parameterToString(outPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["width"].(int32); localVarOk {
		localVarQueryParams.Add("width", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["height"].(int32); localVarOk {
		localVarQueryParams.Add("height", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["password"].(string); localVarOk {
		localVarQueryParams.Add("password", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Convert PCL file (located on storage) to PDF format and upload resulting file to storage. 
 @param name The document name.
 @param srcPath Full source filename (ex. /folder1/folder2/template.pcl)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "dstFolder" (string) The destination document folder.
     @param "storage" (string) The document storage.
 @return AsposeResponse*/
func (a *PdfApiService) PutPclInStorageToPdf(name string, srcPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/create/pcl"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["dstFolder"], "string", "dstFolder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("srcPath", parameterToString(srcPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["dstFolder"].(string); localVarOk {
		localVarQueryParams.Add("dstFolder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Convert PDFA file (located on storage) to PDF format and upload resulting file to storage. 
 @param name The document name.
 @param srcPath Full source filename (ex. /folder1/folder2/template.pdf)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "dstFolder" (string) The destination document folder.
     @param "dontOptimize" (bool) If set, document resources will not be optimized.
     @param "storage" (string) The document storage.
 @return AsposeResponse*/
func (a *PdfApiService) PutPdfAInStorageToPdf(name string, srcPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/create/pdfa"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["dstFolder"], "string", "dstFolder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["dontOptimize"], "bool", "dontOptimize"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("srcPath", parameterToString(srcPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["dstFolder"].(string); localVarOk {
		localVarQueryParams.Add("dstFolder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["dontOptimize"].(bool); localVarOk {
		localVarQueryParams.Add("dontOptimize", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Converts PDF document (in request content) to DOC format and uploads resulting file to storage.
 @param outPath Full resulting filename (ex. /folder1/folder2/result.doc)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "addReturnToLineEnd" (bool) Add return to line end.
     @param "format" (string) Allows to specify .doc or .docx file format.
     @param "imageResolutionX" (int32) Image resolution X.
     @param "imageResolutionY" (int32) Image resolution Y.
     @param "maxDistanceBetweenTextLines" (float64) Max distance between text lines.
     @param "mode" (string) Allows to control how a PDF document is converted into a word processing document.
     @param "recognizeBullets" (bool) Recognize bullets.
     @param "relativeHorizontalProximity" (float64) Relative horizontal proximity.
     @param "storage" (string) The document storage.
     @param "password" (string) The password (Base64).
     @param "file" (*os.File) A file to be converted.
 @return AsposeResponse*/
func (a *PdfApiService) PutPdfInRequestToDoc(outPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/convert/doc"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["addReturnToLineEnd"], "bool", "addReturnToLineEnd"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["format"], "string", "format"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["imageResolutionX"], "int32", "imageResolutionX"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["imageResolutionY"], "int32", "imageResolutionY"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["maxDistanceBetweenTextLines"], "float64", "maxDistanceBetweenTextLines"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["mode"], "string", "mode"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["recognizeBullets"], "bool", "recognizeBullets"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["relativeHorizontalProximity"], "float64", "relativeHorizontalProximity"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["password"], "string", "password"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("outPath", parameterToString(outPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["addReturnToLineEnd"].(bool); localVarOk {
		localVarQueryParams.Add("addReturnToLineEnd", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["format"].(string); localVarOk {
		localVarQueryParams.Add("format", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["imageResolutionX"].(int32); localVarOk {
		localVarQueryParams.Add("imageResolutionX", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["imageResolutionY"].(int32); localVarOk {
		localVarQueryParams.Add("imageResolutionY", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["maxDistanceBetweenTextLines"].(float64); localVarOk {
		localVarQueryParams.Add("maxDistanceBetweenTextLines", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["mode"].(string); localVarOk {
		localVarQueryParams.Add("mode", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["recognizeBullets"].(bool); localVarOk {
		localVarQueryParams.Add("recognizeBullets", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["relativeHorizontalProximity"].(float64); localVarOk {
		localVarQueryParams.Add("relativeHorizontalProximity", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["password"].(string); localVarOk {
		localVarQueryParams.Add("password", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "multipart/form-data",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	var localVarFile (*os.File)
	if localVarTempParam, localVarOk := localVarOptionals["file"].(*os.File); localVarOk {
		localVarFile = localVarTempParam
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Converts PDF document (in request content) to EPUB format and uploads resulting file to storage.
 @param outPath Full resulting filename (ex. /folder1/folder2/result.epub)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "contentRecognitionMode" (string) Property tunes conversion for this or that desirable method of recognition of content.
     @param "storage" (string) The document storage.
     @param "file" (*os.File) A file to be converted.
 @return AsposeResponse*/
func (a *PdfApiService) PutPdfInRequestToEpub(outPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/convert/epub"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["contentRecognitionMode"], "string", "contentRecognitionMode"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("outPath", parameterToString(outPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["contentRecognitionMode"].(string); localVarOk {
		localVarQueryParams.Add("contentRecognitionMode", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "multipart/form-data",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	var localVarFile (*os.File)
	if localVarTempParam, localVarOk := localVarOptionals["file"].(*os.File); localVarOk {
		localVarFile = localVarTempParam
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Converts PDF document (in request content) to Html format and uploads resulting file to storage.
 @param outPath Full resulting filename (ex. /folder1/folder2/result.html)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "additionalMarginWidthInPoints" (int32) Defines width of margin that will be forcibly left around that output HTML-areas.
     @param "compressSvgGraphicsIfAny" (bool) The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving.
     @param "convertMarkedContentToLayers" (bool) If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content.
     @param "defaultFontName" (string) Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used.
     @param "documentType" (string) Result document type.
     @param "fixedLayout" (bool) The value indicating whether that HTML is created as fixed layout.
     @param "imageResolution" (int32) Resolution for image rendering.
     @param "minimalLineWidth" (int32) This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers.
     @param "preventGlyphsGrouping" (bool) This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true.
     @param "splitCssIntoPages" (bool) When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page.
     @param "splitIntoPages" (bool) The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages.
     @param "useZOrder" (bool) If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects.
     @param "antialiasingProcessing" (string) The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML.
     @param "cssClassNamesPrefix" (string) When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix.
     @param "explicitListOfSavedPages" ([]int32) With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF.
     @param "fontEncodingStrategy" (string) Defines encoding special rule to tune PDF decoding for current document.
     @param "fontSavingMode" (string) Defines font saving mode that will be used during saving of PDF to desirable format.
     @param "htmlMarkupGenerationMode" (string) Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments.
     @param "lettersPositioningMethod" (string) The mode of positioning of letters in words in result HTML.
     @param "pagesFlowTypeDependsOnViewersScreenSize" (bool) If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer.
     @param "partsEmbeddingMode" (string) It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities.
     @param "rasterImagesSavingMode" (string) Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML.
     @param "removeEmptyAreasOnTopAndBottom" (bool) Defines whether in created HTML will be removed top and bottom empty area without any content (if any).
     @param "saveShadowedTextsAsTransparentTexts" (bool) Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard).
     @param "saveTransparentTexts" (bool) Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML.
     @param "specialFolderForAllImages" (string) The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file.
     @param "specialFolderForSvgImages" (string) The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file.
     @param "trySaveTextUnderliningAndStrikeoutingInCss" (bool) PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically.
     @param "storage" (string) The document storage.
     @param "flowLayoutParagraphFullWidth" (bool) This attribute specifies full width paragraph text for Flow mode, FixedLayout &#x3D; false.
     @param "outputFormat" (string) This parameter determines the type of result. The zip archive will be uploaded into the storage if the parameter is \&quot;Zip\&quot; or missed (default). In case of the \&quot;Folder\&quot;, all resulting files and directories will be uploaded to the folder of the resulting HTML file.
     @param "file" (*os.File) A file to be converted.
 @return AsposeResponse*/
func (a *PdfApiService) PutPdfInRequestToHtml(outPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/convert/html"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["additionalMarginWidthInPoints"], "int32", "additionalMarginWidthInPoints"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["compressSvgGraphicsIfAny"], "bool", "compressSvgGraphicsIfAny"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["convertMarkedContentToLayers"], "bool", "convertMarkedContentToLayers"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["defaultFontName"], "string", "defaultFontName"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["documentType"], "string", "documentType"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["fixedLayout"], "bool", "fixedLayout"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["imageResolution"], "int32", "imageResolution"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["minimalLineWidth"], "int32", "minimalLineWidth"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["preventGlyphsGrouping"], "bool", "preventGlyphsGrouping"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["splitCssIntoPages"], "bool", "splitCssIntoPages"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["splitIntoPages"], "bool", "splitIntoPages"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["useZOrder"], "bool", "useZOrder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["antialiasingProcessing"], "string", "antialiasingProcessing"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["cssClassNamesPrefix"], "string", "cssClassNamesPrefix"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["fontEncodingStrategy"], "string", "fontEncodingStrategy"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["fontSavingMode"], "string", "fontSavingMode"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["htmlMarkupGenerationMode"], "string", "htmlMarkupGenerationMode"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["lettersPositioningMethod"], "string", "lettersPositioningMethod"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["pagesFlowTypeDependsOnViewersScreenSize"], "bool", "pagesFlowTypeDependsOnViewersScreenSize"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["partsEmbeddingMode"], "string", "partsEmbeddingMode"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["rasterImagesSavingMode"], "string", "rasterImagesSavingMode"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["removeEmptyAreasOnTopAndBottom"], "bool", "removeEmptyAreasOnTopAndBottom"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["saveShadowedTextsAsTransparentTexts"], "bool", "saveShadowedTextsAsTransparentTexts"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["saveTransparentTexts"], "bool", "saveTransparentTexts"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["specialFolderForAllImages"], "string", "specialFolderForAllImages"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["specialFolderForSvgImages"], "string", "specialFolderForSvgImages"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["trySaveTextUnderliningAndStrikeoutingInCss"], "bool", "trySaveTextUnderliningAndStrikeoutingInCss"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["flowLayoutParagraphFullWidth"], "bool", "flowLayoutParagraphFullWidth"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["outputFormat"], "string", "outputFormat"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("outPath", parameterToString(outPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["additionalMarginWidthInPoints"].(int32); localVarOk {
		localVarQueryParams.Add("additionalMarginWidthInPoints", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["compressSvgGraphicsIfAny"].(bool); localVarOk {
		localVarQueryParams.Add("compressSvgGraphicsIfAny", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["convertMarkedContentToLayers"].(bool); localVarOk {
		localVarQueryParams.Add("convertMarkedContentToLayers", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["defaultFontName"].(string); localVarOk {
		localVarQueryParams.Add("defaultFontName", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["documentType"].(string); localVarOk {
		localVarQueryParams.Add("documentType", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["fixedLayout"].(bool); localVarOk {
		localVarQueryParams.Add("fixedLayout", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["imageResolution"].(int32); localVarOk {
		localVarQueryParams.Add("imageResolution", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["minimalLineWidth"].(int32); localVarOk {
		localVarQueryParams.Add("minimalLineWidth", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["preventGlyphsGrouping"].(bool); localVarOk {
		localVarQueryParams.Add("preventGlyphsGrouping", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["splitCssIntoPages"].(bool); localVarOk {
		localVarQueryParams.Add("splitCssIntoPages", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["splitIntoPages"].(bool); localVarOk {
		localVarQueryParams.Add("splitIntoPages", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["useZOrder"].(bool); localVarOk {
		localVarQueryParams.Add("useZOrder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["antialiasingProcessing"].(string); localVarOk {
		localVarQueryParams.Add("antialiasingProcessing", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["cssClassNamesPrefix"].(string); localVarOk {
		localVarQueryParams.Add("cssClassNamesPrefix", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["explicitListOfSavedPages"].([]int32); localVarOk {
		localVarQueryParams.Add("explicitListOfSavedPages", parameterToString(localVarTempParam, "csv"))
	}
	if localVarTempParam, localVarOk := localVarOptionals["fontEncodingStrategy"].(string); localVarOk {
		localVarQueryParams.Add("fontEncodingStrategy", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["fontSavingMode"].(string); localVarOk {
		localVarQueryParams.Add("fontSavingMode", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["htmlMarkupGenerationMode"].(string); localVarOk {
		localVarQueryParams.Add("htmlMarkupGenerationMode", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["lettersPositioningMethod"].(string); localVarOk {
		localVarQueryParams.Add("lettersPositioningMethod", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["pagesFlowTypeDependsOnViewersScreenSize"].(bool); localVarOk {
		localVarQueryParams.Add("pagesFlowTypeDependsOnViewersScreenSize", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["partsEmbeddingMode"].(string); localVarOk {
		localVarQueryParams.Add("partsEmbeddingMode", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["rasterImagesSavingMode"].(string); localVarOk {
		localVarQueryParams.Add("rasterImagesSavingMode", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["removeEmptyAreasOnTopAndBottom"].(bool); localVarOk {
		localVarQueryParams.Add("removeEmptyAreasOnTopAndBottom", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["saveShadowedTextsAsTransparentTexts"].(bool); localVarOk {
		localVarQueryParams.Add("saveShadowedTextsAsTransparentTexts", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["saveTransparentTexts"].(bool); localVarOk {
		localVarQueryParams.Add("saveTransparentTexts", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["specialFolderForAllImages"].(string); localVarOk {
		localVarQueryParams.Add("specialFolderForAllImages", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["specialFolderForSvgImages"].(string); localVarOk {
		localVarQueryParams.Add("specialFolderForSvgImages", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["trySaveTextUnderliningAndStrikeoutingInCss"].(bool); localVarOk {
		localVarQueryParams.Add("trySaveTextUnderliningAndStrikeoutingInCss", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["flowLayoutParagraphFullWidth"].(bool); localVarOk {
		localVarQueryParams.Add("flowLayoutParagraphFullWidth", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["outputFormat"].(string); localVarOk {
		localVarQueryParams.Add("outputFormat", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "multipart/form-data",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	var localVarFile (*os.File)
	if localVarTempParam, localVarOk := localVarOptionals["file"].(*os.File); localVarOk {
		localVarFile = localVarTempParam
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Converts PDF document (in request content) to MOBIXML format and uploads resulting ZIP archive file to storage.
 @param outPath Full resulting filename (ex. /folder1/folder2/result.mobixml)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "file" (*os.File) A file to be converted.
 @return AsposeResponse*/
func (a *PdfApiService) PutPdfInRequestToMobiXml(outPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/convert/mobixml"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("outPath", parameterToString(outPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "multipart/form-data",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	var localVarFile (*os.File)
	if localVarTempParam, localVarOk := localVarOptionals["file"].(*os.File); localVarOk {
		localVarFile = localVarTempParam
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Converts PDF document (in request content) to PdfA format and uploads resulting file to storage.
 @param outPath Full resulting filename (ex. /folder1/folder2/result.pdf)
 @param type_ Type of PdfA format.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "file" (*os.File) A file to be converted.
 @return AsposeResponse*/
func (a *PdfApiService) PutPdfInRequestToPdfA(outPath string, type_ string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/convert/pdfa"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("outPath", parameterToString(outPath, ""))
	localVarQueryParams.Add("type", parameterToString(type_, ""))
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "multipart/form-data",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	var localVarFile (*os.File)
	if localVarTempParam, localVarOk := localVarOptionals["file"].(*os.File); localVarOk {
		localVarFile = localVarTempParam
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Converts PDF document (in request content) to PPTX format and uploads resulting file to storage.
 @param outPath Full resulting filename (ex. /folder1/folder2/result.pptx)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "separateImages" (bool) Separate images.
     @param "slidesAsImages" (bool) Slides as images.
     @param "storage" (string) The document storage.
     @param "password" (string) Base64 encoded password.
     @param "file" (*os.File) A file to be converted.
 @return AsposeResponse*/
func (a *PdfApiService) PutPdfInRequestToPptx(outPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/convert/pptx"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["separateImages"], "bool", "separateImages"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["slidesAsImages"], "bool", "slidesAsImages"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["password"], "string", "password"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("outPath", parameterToString(outPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["separateImages"].(bool); localVarOk {
		localVarQueryParams.Add("separateImages", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["slidesAsImages"].(bool); localVarOk {
		localVarQueryParams.Add("slidesAsImages", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["password"].(string); localVarOk {
		localVarQueryParams.Add("password", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "multipart/form-data",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	var localVarFile (*os.File)
	if localVarTempParam, localVarOk := localVarOptionals["file"].(*os.File); localVarOk {
		localVarFile = localVarTempParam
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Converts PDF document (in request content) to SVG format and uploads resulting file to storage.
 @param outPath Full resulting filename (ex. /folder1/folder2/result.svg)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "file" (*os.File) A file to be converted.
 @return AsposeResponse*/
func (a *PdfApiService) PutPdfInRequestToSvg(outPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/convert/svg"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("outPath", parameterToString(outPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "multipart/form-data",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	var localVarFile (*os.File)
	if localVarTempParam, localVarOk := localVarOptionals["file"].(*os.File); localVarOk {
		localVarFile = localVarTempParam
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Converts PDF document (in request content) to TeX format and uploads resulting file to storage.
 @param outPath Full resulting filename (ex. /folder1/folder2/result.tex)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "file" (*os.File) A file to be converted.
 @return AsposeResponse*/
func (a *PdfApiService) PutPdfInRequestToTeX(outPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/convert/tex"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("outPath", parameterToString(outPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "multipart/form-data",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	var localVarFile (*os.File)
	if localVarTempParam, localVarOk := localVarOptionals["file"].(*os.File); localVarOk {
		localVarFile = localVarTempParam
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Converts PDF document (in request content) to TIFF format and uploads resulting file to storage.
 @param outPath Full resulting filename (ex. /folder1/folder2/result.tiff)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "brightness" (float64) Image brightness.
     @param "compression" (string) Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None.
     @param "colorDepth" (string) Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp.
     @param "leftMargin" (int32) Left image margin.
     @param "rightMargin" (int32) Right image margin.
     @param "topMargin" (int32) Top image margin.
     @param "bottomMargin" (int32) Bottom image margin.
     @param "orientation" (string) Image orientation. Possible values are: None, Landscape, Portait.
     @param "skipBlankPages" (bool) Skip blank pages flag.
     @param "width" (int32) Image width.
     @param "height" (int32) Image height.
     @param "xResolution" (int32) Horizontal resolution.
     @param "yResolution" (int32) Vertical resolution.
     @param "pageIndex" (int32) Start page to export.
     @param "pageCount" (int32) Number of pages to export.
     @param "storage" (string) The document storage.
     @param "file" (*os.File) A file to be converted.
 @return AsposeResponse*/
func (a *PdfApiService) PutPdfInRequestToTiff(outPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/convert/tiff"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["brightness"], "float64", "brightness"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["compression"], "string", "compression"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["colorDepth"], "string", "colorDepth"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["leftMargin"], "int32", "leftMargin"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["rightMargin"], "int32", "rightMargin"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["topMargin"], "int32", "topMargin"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["bottomMargin"], "int32", "bottomMargin"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["orientation"], "string", "orientation"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["skipBlankPages"], "bool", "skipBlankPages"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["width"], "int32", "width"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["height"], "int32", "height"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["xResolution"], "int32", "xResolution"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["yResolution"], "int32", "yResolution"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["pageIndex"], "int32", "pageIndex"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["pageCount"], "int32", "pageCount"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("outPath", parameterToString(outPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["brightness"].(float64); localVarOk {
		localVarQueryParams.Add("brightness", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["compression"].(string); localVarOk {
		localVarQueryParams.Add("compression", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["colorDepth"].(string); localVarOk {
		localVarQueryParams.Add("colorDepth", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["leftMargin"].(int32); localVarOk {
		localVarQueryParams.Add("leftMargin", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["rightMargin"].(int32); localVarOk {
		localVarQueryParams.Add("rightMargin", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["topMargin"].(int32); localVarOk {
		localVarQueryParams.Add("topMargin", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["bottomMargin"].(int32); localVarOk {
		localVarQueryParams.Add("bottomMargin", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["orientation"].(string); localVarOk {
		localVarQueryParams.Add("orientation", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["skipBlankPages"].(bool); localVarOk {
		localVarQueryParams.Add("skipBlankPages", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["width"].(int32); localVarOk {
		localVarQueryParams.Add("width", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["height"].(int32); localVarOk {
		localVarQueryParams.Add("height", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["xResolution"].(int32); localVarOk {
		localVarQueryParams.Add("xResolution", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["yResolution"].(int32); localVarOk {
		localVarQueryParams.Add("yResolution", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["pageIndex"].(int32); localVarOk {
		localVarQueryParams.Add("pageIndex", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["pageCount"].(int32); localVarOk {
		localVarQueryParams.Add("pageCount", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "multipart/form-data",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	var localVarFile (*os.File)
	if localVarTempParam, localVarOk := localVarOptionals["file"].(*os.File); localVarOk {
		localVarFile = localVarTempParam
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Converts PDF document (in request content) to XLS format and uploads resulting file to storage.
 @param outPath Full resulting filename (ex. /folder1/folder2/result.xls)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "insertBlankColumnAtFirst" (bool) Insert blank column at first
     @param "minimizeTheNumberOfWorksheets" (bool) Minimize the number of worksheets
     @param "scaleFactor" (float64) Scale factor (Obsolete)
     @param "uniformWorksheets" (bool) Uniform worksheets
     @param "storage" (string) The document storage.
     @param "password" (string) The password (Base64).
     @param "file" (*os.File) A file to be converted.
 @return AsposeResponse*/
func (a *PdfApiService) PutPdfInRequestToXls(outPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/convert/xls"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["insertBlankColumnAtFirst"], "bool", "insertBlankColumnAtFirst"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["minimizeTheNumberOfWorksheets"], "bool", "minimizeTheNumberOfWorksheets"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["scaleFactor"], "float64", "scaleFactor"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["uniformWorksheets"], "bool", "uniformWorksheets"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["password"], "string", "password"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("outPath", parameterToString(outPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["insertBlankColumnAtFirst"].(bool); localVarOk {
		localVarQueryParams.Add("insertBlankColumnAtFirst", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["minimizeTheNumberOfWorksheets"].(bool); localVarOk {
		localVarQueryParams.Add("minimizeTheNumberOfWorksheets", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["scaleFactor"].(float64); localVarOk {
		localVarQueryParams.Add("scaleFactor", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["uniformWorksheets"].(bool); localVarOk {
		localVarQueryParams.Add("uniformWorksheets", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["password"].(string); localVarOk {
		localVarQueryParams.Add("password", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "multipart/form-data",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	var localVarFile (*os.File)
	if localVarTempParam, localVarOk := localVarOptionals["file"].(*os.File); localVarOk {
		localVarFile = localVarTempParam
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Converts PDF document (in request content) to XLSX format and uploads resulting file to storage.
 @param outPath Full resulting filename (ex. /folder1/folder2/result.xlsx)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "insertBlankColumnAtFirst" (bool) Insert blank column at first
     @param "minimizeTheNumberOfWorksheets" (bool) Minimize the number of worksheets
     @param "scaleFactor" (float64) Scale factor (Obsolete)
     @param "uniformWorksheets" (bool) Uniform worksheets
     @param "storage" (string) The document storage.
     @param "password" (string) The password (Base64).
     @param "file" (*os.File) A file to be converted.
 @return AsposeResponse*/
func (a *PdfApiService) PutPdfInRequestToXlsx(outPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/convert/xlsx"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["insertBlankColumnAtFirst"], "bool", "insertBlankColumnAtFirst"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["minimizeTheNumberOfWorksheets"], "bool", "minimizeTheNumberOfWorksheets"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["scaleFactor"], "float64", "scaleFactor"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["uniformWorksheets"], "bool", "uniformWorksheets"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["password"], "string", "password"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("outPath", parameterToString(outPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["insertBlankColumnAtFirst"].(bool); localVarOk {
		localVarQueryParams.Add("insertBlankColumnAtFirst", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["minimizeTheNumberOfWorksheets"].(bool); localVarOk {
		localVarQueryParams.Add("minimizeTheNumberOfWorksheets", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["scaleFactor"].(float64); localVarOk {
		localVarQueryParams.Add("scaleFactor", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["uniformWorksheets"].(bool); localVarOk {
		localVarQueryParams.Add("uniformWorksheets", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["password"].(string); localVarOk {
		localVarQueryParams.Add("password", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "multipart/form-data",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	var localVarFile (*os.File)
	if localVarTempParam, localVarOk := localVarOptionals["file"].(*os.File); localVarOk {
		localVarFile = localVarTempParam
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Converts PDF document (in request content) to XML format and uploads resulting file to storage.
 @param outPath Full resulting filename (ex. /folder1/folder2/result.xml)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "file" (*os.File) A file to be converted.
 @return AsposeResponse*/
func (a *PdfApiService) PutPdfInRequestToXml(outPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/convert/xml"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("outPath", parameterToString(outPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "multipart/form-data",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	var localVarFile (*os.File)
	if localVarTempParam, localVarOk := localVarOptionals["file"].(*os.File); localVarOk {
		localVarFile = localVarTempParam
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Converts PDF document (in request content) to XPS format and uploads resulting file to storage.
 @param outPath Full resulting filename (ex. /folder1/folder2/result.xps)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "file" (*os.File) A file to be converted.
 @return AsposeResponse*/
func (a *PdfApiService) PutPdfInRequestToXps(outPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/convert/xps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("outPath", parameterToString(outPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "multipart/form-data",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	var localVarFile (*os.File)
	if localVarTempParam, localVarOk := localVarOptionals["file"].(*os.File); localVarOk {
		localVarFile = localVarTempParam
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Converts PDF document (located on storage) to DOC format and uploads resulting file to storage.
 @param name The document name.
 @param outPath Full resulting filename (ex. /folder1/folder2/result.doc)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "addReturnToLineEnd" (bool) Add return to line end.
     @param "format" (string) Allows to specify .doc or .docx file format.
     @param "imageResolutionX" (int32) Image resolution X.
     @param "imageResolutionY" (int32) Image resolution Y.
     @param "maxDistanceBetweenTextLines" (float64) Max distance between text lines.
     @param "mode" (string) Allows to control how a PDF document is converted into a word processing document.
     @param "recognizeBullets" (bool) Recognize bullets.
     @param "relativeHorizontalProximity" (float64) Relative horizontal proximity.
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
     @param "password" (string) The password (Base64).
 @return AsposeResponse*/
func (a *PdfApiService) PutPdfInStorageToDoc(name string, outPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/convert/doc"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["addReturnToLineEnd"], "bool", "addReturnToLineEnd"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["format"], "string", "format"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["imageResolutionX"], "int32", "imageResolutionX"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["imageResolutionY"], "int32", "imageResolutionY"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["maxDistanceBetweenTextLines"], "float64", "maxDistanceBetweenTextLines"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["mode"], "string", "mode"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["recognizeBullets"], "bool", "recognizeBullets"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["relativeHorizontalProximity"], "float64", "relativeHorizontalProximity"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["password"], "string", "password"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("outPath", parameterToString(outPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["addReturnToLineEnd"].(bool); localVarOk {
		localVarQueryParams.Add("addReturnToLineEnd", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["format"].(string); localVarOk {
		localVarQueryParams.Add("format", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["imageResolutionX"].(int32); localVarOk {
		localVarQueryParams.Add("imageResolutionX", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["imageResolutionY"].(int32); localVarOk {
		localVarQueryParams.Add("imageResolutionY", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["maxDistanceBetweenTextLines"].(float64); localVarOk {
		localVarQueryParams.Add("maxDistanceBetweenTextLines", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["mode"].(string); localVarOk {
		localVarQueryParams.Add("mode", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["recognizeBullets"].(bool); localVarOk {
		localVarQueryParams.Add("recognizeBullets", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["relativeHorizontalProximity"].(float64); localVarOk {
		localVarQueryParams.Add("relativeHorizontalProximity", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["password"].(string); localVarOk {
		localVarQueryParams.Add("password", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Converts PDF document (located on storage) to EPUB format and uploads resulting file to storage
 @param name The document name.
 @param outPath Full resulting filename (ex. /folder1/folder2/result.epub)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "contentRecognitionMode" (string) Property tunes conversion for this or that desirable method of recognition of content.
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
 @return AsposeResponse*/
func (a *PdfApiService) PutPdfInStorageToEpub(name string, outPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/convert/epub"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["contentRecognitionMode"], "string", "contentRecognitionMode"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("outPath", parameterToString(outPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["contentRecognitionMode"].(string); localVarOk {
		localVarQueryParams.Add("contentRecognitionMode", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Converts PDF document (located on storage) to Html format and uploads resulting file to storage
 @param name The document name.
 @param outPath Full resulting filename (ex. /folder1/folder2/result.html)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "additionalMarginWidthInPoints" (int32) Defines width of margin that will be forcibly left around that output HTML-areas.
     @param "compressSvgGraphicsIfAny" (bool) The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving.
     @param "convertMarkedContentToLayers" (bool) If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content.
     @param "defaultFontName" (string) Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used.
     @param "documentType" (string) Result document type.
     @param "fixedLayout" (bool) The value indicating whether that HTML is created as fixed layout.
     @param "imageResolution" (int32) Resolution for image rendering.
     @param "minimalLineWidth" (int32) This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers.
     @param "preventGlyphsGrouping" (bool) This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true.
     @param "splitCssIntoPages" (bool) When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page.
     @param "splitIntoPages" (bool) The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages.
     @param "useZOrder" (bool) If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects.
     @param "antialiasingProcessing" (string) The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML.
     @param "cssClassNamesPrefix" (string) When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix.
     @param "explicitListOfSavedPages" ([]int32) With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF.
     @param "fontEncodingStrategy" (string) Defines encoding special rule to tune PDF decoding for current document.
     @param "fontSavingMode" (string) Defines font saving mode that will be used during saving of PDF to desirable format.
     @param "htmlMarkupGenerationMode" (string) Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments.
     @param "lettersPositioningMethod" (string) The mode of positioning of letters in words in result HTML.
     @param "pagesFlowTypeDependsOnViewersScreenSize" (bool) If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer.
     @param "partsEmbeddingMode" (string) It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities.
     @param "rasterImagesSavingMode" (string) Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML.
     @param "removeEmptyAreasOnTopAndBottom" (bool) Defines whether in created HTML will be removed top and bottom empty area without any content (if any).
     @param "saveShadowedTextsAsTransparentTexts" (bool) Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard).
     @param "saveTransparentTexts" (bool) Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML.
     @param "specialFolderForAllImages" (string) The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file.
     @param "specialFolderForSvgImages" (string) The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file.
     @param "trySaveTextUnderliningAndStrikeoutingInCss" (bool) PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically.
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
     @param "flowLayoutParagraphFullWidth" (bool) This attribute specifies full width paragraph text for Flow mode, FixedLayout &#x3D; false.
     @param "outputFormat" (string) This parameter determines the type of result. The zip archive will be uploaded into the storage if the parameter is \&quot;Zip\&quot; or missed (default). In case of the \&quot;Folder\&quot;, all resulting files and directories will be uploaded to the folder of the resulting HTML file.
 @return AsposeResponse*/
func (a *PdfApiService) PutPdfInStorageToHtml(name string, outPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/convert/html"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["additionalMarginWidthInPoints"], "int32", "additionalMarginWidthInPoints"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["compressSvgGraphicsIfAny"], "bool", "compressSvgGraphicsIfAny"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["convertMarkedContentToLayers"], "bool", "convertMarkedContentToLayers"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["defaultFontName"], "string", "defaultFontName"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["documentType"], "string", "documentType"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["fixedLayout"], "bool", "fixedLayout"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["imageResolution"], "int32", "imageResolution"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["minimalLineWidth"], "int32", "minimalLineWidth"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["preventGlyphsGrouping"], "bool", "preventGlyphsGrouping"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["splitCssIntoPages"], "bool", "splitCssIntoPages"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["splitIntoPages"], "bool", "splitIntoPages"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["useZOrder"], "bool", "useZOrder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["antialiasingProcessing"], "string", "antialiasingProcessing"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["cssClassNamesPrefix"], "string", "cssClassNamesPrefix"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["fontEncodingStrategy"], "string", "fontEncodingStrategy"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["fontSavingMode"], "string", "fontSavingMode"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["htmlMarkupGenerationMode"], "string", "htmlMarkupGenerationMode"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["lettersPositioningMethod"], "string", "lettersPositioningMethod"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["pagesFlowTypeDependsOnViewersScreenSize"], "bool", "pagesFlowTypeDependsOnViewersScreenSize"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["partsEmbeddingMode"], "string", "partsEmbeddingMode"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["rasterImagesSavingMode"], "string", "rasterImagesSavingMode"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["removeEmptyAreasOnTopAndBottom"], "bool", "removeEmptyAreasOnTopAndBottom"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["saveShadowedTextsAsTransparentTexts"], "bool", "saveShadowedTextsAsTransparentTexts"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["saveTransparentTexts"], "bool", "saveTransparentTexts"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["specialFolderForAllImages"], "string", "specialFolderForAllImages"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["specialFolderForSvgImages"], "string", "specialFolderForSvgImages"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["trySaveTextUnderliningAndStrikeoutingInCss"], "bool", "trySaveTextUnderliningAndStrikeoutingInCss"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["flowLayoutParagraphFullWidth"], "bool", "flowLayoutParagraphFullWidth"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["outputFormat"], "string", "outputFormat"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("outPath", parameterToString(outPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["additionalMarginWidthInPoints"].(int32); localVarOk {
		localVarQueryParams.Add("additionalMarginWidthInPoints", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["compressSvgGraphicsIfAny"].(bool); localVarOk {
		localVarQueryParams.Add("compressSvgGraphicsIfAny", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["convertMarkedContentToLayers"].(bool); localVarOk {
		localVarQueryParams.Add("convertMarkedContentToLayers", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["defaultFontName"].(string); localVarOk {
		localVarQueryParams.Add("defaultFontName", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["documentType"].(string); localVarOk {
		localVarQueryParams.Add("documentType", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["fixedLayout"].(bool); localVarOk {
		localVarQueryParams.Add("fixedLayout", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["imageResolution"].(int32); localVarOk {
		localVarQueryParams.Add("imageResolution", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["minimalLineWidth"].(int32); localVarOk {
		localVarQueryParams.Add("minimalLineWidth", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["preventGlyphsGrouping"].(bool); localVarOk {
		localVarQueryParams.Add("preventGlyphsGrouping", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["splitCssIntoPages"].(bool); localVarOk {
		localVarQueryParams.Add("splitCssIntoPages", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["splitIntoPages"].(bool); localVarOk {
		localVarQueryParams.Add("splitIntoPages", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["useZOrder"].(bool); localVarOk {
		localVarQueryParams.Add("useZOrder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["antialiasingProcessing"].(string); localVarOk {
		localVarQueryParams.Add("antialiasingProcessing", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["cssClassNamesPrefix"].(string); localVarOk {
		localVarQueryParams.Add("cssClassNamesPrefix", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["explicitListOfSavedPages"].([]int32); localVarOk {
		localVarQueryParams.Add("explicitListOfSavedPages", parameterToString(localVarTempParam, "csv"))
	}
	if localVarTempParam, localVarOk := localVarOptionals["fontEncodingStrategy"].(string); localVarOk {
		localVarQueryParams.Add("fontEncodingStrategy", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["fontSavingMode"].(string); localVarOk {
		localVarQueryParams.Add("fontSavingMode", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["htmlMarkupGenerationMode"].(string); localVarOk {
		localVarQueryParams.Add("htmlMarkupGenerationMode", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["lettersPositioningMethod"].(string); localVarOk {
		localVarQueryParams.Add("lettersPositioningMethod", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["pagesFlowTypeDependsOnViewersScreenSize"].(bool); localVarOk {
		localVarQueryParams.Add("pagesFlowTypeDependsOnViewersScreenSize", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["partsEmbeddingMode"].(string); localVarOk {
		localVarQueryParams.Add("partsEmbeddingMode", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["rasterImagesSavingMode"].(string); localVarOk {
		localVarQueryParams.Add("rasterImagesSavingMode", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["removeEmptyAreasOnTopAndBottom"].(bool); localVarOk {
		localVarQueryParams.Add("removeEmptyAreasOnTopAndBottom", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["saveShadowedTextsAsTransparentTexts"].(bool); localVarOk {
		localVarQueryParams.Add("saveShadowedTextsAsTransparentTexts", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["saveTransparentTexts"].(bool); localVarOk {
		localVarQueryParams.Add("saveTransparentTexts", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["specialFolderForAllImages"].(string); localVarOk {
		localVarQueryParams.Add("specialFolderForAllImages", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["specialFolderForSvgImages"].(string); localVarOk {
		localVarQueryParams.Add("specialFolderForSvgImages", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["trySaveTextUnderliningAndStrikeoutingInCss"].(bool); localVarOk {
		localVarQueryParams.Add("trySaveTextUnderliningAndStrikeoutingInCss", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["flowLayoutParagraphFullWidth"].(bool); localVarOk {
		localVarQueryParams.Add("flowLayoutParagraphFullWidth", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["outputFormat"].(string); localVarOk {
		localVarQueryParams.Add("outputFormat", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Converts PDF document (located on storage) to MOBIXML format and uploads resulting ZIP archive file to storage
 @param name The document name.
 @param outPath Full resulting filename (ex. /folder1/folder2/result.mobixml)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
 @return AsposeResponse*/
func (a *PdfApiService) PutPdfInStorageToMobiXml(name string, outPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/convert/mobixml"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("outPath", parameterToString(outPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Converts PDF document (located on storage) to PdfA format and uploads resulting file to storage
 @param name The document name.
 @param outPath Full resulting filename (ex. /folder1/folder2/result.pdf)
 @param type_ Type of PdfA format.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
 @return AsposeResponse*/
func (a *PdfApiService) PutPdfInStorageToPdfA(name string, outPath string, type_ string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/convert/pdfa"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("outPath", parameterToString(outPath, ""))
	localVarQueryParams.Add("type", parameterToString(type_, ""))
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Converts PDF document (located on storage) to PPTX format and uploads resulting file to storage
 @param name The document name.
 @param outPath Full resulting filename (ex. /folder1/folder2/result.pptx)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "separateImages" (bool) Separate images.
     @param "slidesAsImages" (bool) Slides as images.
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
     @param "password" (string) Base64 encoded password.
 @return AsposeResponse*/
func (a *PdfApiService) PutPdfInStorageToPptx(name string, outPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/convert/pptx"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["separateImages"], "bool", "separateImages"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["slidesAsImages"], "bool", "slidesAsImages"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["password"], "string", "password"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("outPath", parameterToString(outPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["separateImages"].(bool); localVarOk {
		localVarQueryParams.Add("separateImages", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["slidesAsImages"].(bool); localVarOk {
		localVarQueryParams.Add("slidesAsImages", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["password"].(string); localVarOk {
		localVarQueryParams.Add("password", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Converts PDF document (located on storage) to SVG format and uploads resulting file to storage
 @param name The document name.
 @param outPath Full resulting filename (ex. /folder1/folder2/result.svg)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
 @return AsposeResponse*/
func (a *PdfApiService) PutPdfInStorageToSvg(name string, outPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/convert/svg"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("outPath", parameterToString(outPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Converts PDF document (located on storage) to TeX format and uploads resulting file to storage
 @param name The document name.
 @param outPath Full resulting filename (ex. /folder1/folder2/result.tex)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
 @return AsposeResponse*/
func (a *PdfApiService) PutPdfInStorageToTeX(name string, outPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/convert/tex"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("outPath", parameterToString(outPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Converts PDF document (located on storage) to TIFF format and uploads resulting file to storage
 @param name The document name.
 @param outPath Full resulting filename (ex. /folder1/folder2/result.tiff)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "brightness" (float64) Image brightness.
     @param "compression" (string) Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None.
     @param "colorDepth" (string) Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp.
     @param "leftMargin" (int32) Left image margin.
     @param "rightMargin" (int32) Right image margin.
     @param "topMargin" (int32) Top image margin.
     @param "bottomMargin" (int32) Bottom image margin.
     @param "orientation" (string) Image orientation. Possible values are: None, Landscape, Portait.
     @param "skipBlankPages" (bool) Skip blank pages flag.
     @param "width" (int32) Image width.
     @param "height" (int32) Image height.
     @param "xResolution" (int32) Horizontal resolution.
     @param "yResolution" (int32) Vertical resolution.
     @param "pageIndex" (int32) Start page to export.
     @param "pageCount" (int32) Number of pages to export.
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
 @return AsposeResponse*/
func (a *PdfApiService) PutPdfInStorageToTiff(name string, outPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/convert/tiff"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["brightness"], "float64", "brightness"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["compression"], "string", "compression"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["colorDepth"], "string", "colorDepth"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["leftMargin"], "int32", "leftMargin"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["rightMargin"], "int32", "rightMargin"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["topMargin"], "int32", "topMargin"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["bottomMargin"], "int32", "bottomMargin"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["orientation"], "string", "orientation"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["skipBlankPages"], "bool", "skipBlankPages"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["width"], "int32", "width"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["height"], "int32", "height"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["xResolution"], "int32", "xResolution"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["yResolution"], "int32", "yResolution"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["pageIndex"], "int32", "pageIndex"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["pageCount"], "int32", "pageCount"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("outPath", parameterToString(outPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["brightness"].(float64); localVarOk {
		localVarQueryParams.Add("brightness", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["compression"].(string); localVarOk {
		localVarQueryParams.Add("compression", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["colorDepth"].(string); localVarOk {
		localVarQueryParams.Add("colorDepth", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["leftMargin"].(int32); localVarOk {
		localVarQueryParams.Add("leftMargin", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["rightMargin"].(int32); localVarOk {
		localVarQueryParams.Add("rightMargin", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["topMargin"].(int32); localVarOk {
		localVarQueryParams.Add("topMargin", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["bottomMargin"].(int32); localVarOk {
		localVarQueryParams.Add("bottomMargin", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["orientation"].(string); localVarOk {
		localVarQueryParams.Add("orientation", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["skipBlankPages"].(bool); localVarOk {
		localVarQueryParams.Add("skipBlankPages", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["width"].(int32); localVarOk {
		localVarQueryParams.Add("width", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["height"].(int32); localVarOk {
		localVarQueryParams.Add("height", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["xResolution"].(int32); localVarOk {
		localVarQueryParams.Add("xResolution", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["yResolution"].(int32); localVarOk {
		localVarQueryParams.Add("yResolution", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["pageIndex"].(int32); localVarOk {
		localVarQueryParams.Add("pageIndex", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["pageCount"].(int32); localVarOk {
		localVarQueryParams.Add("pageCount", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Converts PDF document (located on storage) to XLS format and uploads resulting file to storage
 @param name The document name.
 @param outPath Full resulting filename (ex. /folder1/folder2/result.xls)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "insertBlankColumnAtFirst" (bool) Insert blank column at first
     @param "minimizeTheNumberOfWorksheets" (bool) Minimize the number of worksheets
     @param "scaleFactor" (float64) Scale factor (Obsolete)
     @param "uniformWorksheets" (bool) Uniform worksheets
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
     @param "password" (string) The password (Base64).
 @return AsposeResponse*/
func (a *PdfApiService) PutPdfInStorageToXls(name string, outPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/convert/xls"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["insertBlankColumnAtFirst"], "bool", "insertBlankColumnAtFirst"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["minimizeTheNumberOfWorksheets"], "bool", "minimizeTheNumberOfWorksheets"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["scaleFactor"], "float64", "scaleFactor"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["uniformWorksheets"], "bool", "uniformWorksheets"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["password"], "string", "password"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("outPath", parameterToString(outPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["insertBlankColumnAtFirst"].(bool); localVarOk {
		localVarQueryParams.Add("insertBlankColumnAtFirst", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["minimizeTheNumberOfWorksheets"].(bool); localVarOk {
		localVarQueryParams.Add("minimizeTheNumberOfWorksheets", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["scaleFactor"].(float64); localVarOk {
		localVarQueryParams.Add("scaleFactor", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["uniformWorksheets"].(bool); localVarOk {
		localVarQueryParams.Add("uniformWorksheets", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["password"].(string); localVarOk {
		localVarQueryParams.Add("password", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Converts PDF document (located on storage) to XLSX format and uploads resulting file to storage
 @param name The document name.
 @param outPath Full resulting filename (ex. /folder1/folder2/result.xlsx)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "insertBlankColumnAtFirst" (bool) Insert blank column at first
     @param "minimizeTheNumberOfWorksheets" (bool) Minimize the number of worksheets
     @param "scaleFactor" (float64) Scale factor (Obsolete)
     @param "uniformWorksheets" (bool) Uniform worksheets
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
     @param "password" (string) The password (Base64).
 @return AsposeResponse*/
func (a *PdfApiService) PutPdfInStorageToXlsx(name string, outPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/convert/xlsx"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["insertBlankColumnAtFirst"], "bool", "insertBlankColumnAtFirst"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["minimizeTheNumberOfWorksheets"], "bool", "minimizeTheNumberOfWorksheets"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["scaleFactor"], "float64", "scaleFactor"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["uniformWorksheets"], "bool", "uniformWorksheets"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["password"], "string", "password"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("outPath", parameterToString(outPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["insertBlankColumnAtFirst"].(bool); localVarOk {
		localVarQueryParams.Add("insertBlankColumnAtFirst", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["minimizeTheNumberOfWorksheets"].(bool); localVarOk {
		localVarQueryParams.Add("minimizeTheNumberOfWorksheets", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["scaleFactor"].(float64); localVarOk {
		localVarQueryParams.Add("scaleFactor", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["uniformWorksheets"].(bool); localVarOk {
		localVarQueryParams.Add("uniformWorksheets", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["password"].(string); localVarOk {
		localVarQueryParams.Add("password", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Converts PDF document (located on storage) to XML format and uploads resulting file to storage
 @param name The document name.
 @param outPath Full resulting filename (ex. /folder1/folder2/result.xml)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
 @return AsposeResponse*/
func (a *PdfApiService) PutPdfInStorageToXml(name string, outPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/convert/xml"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("outPath", parameterToString(outPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Converts PDF document (located on storage) to XPS format and uploads resulting file to storage
 @param name The document name.
 @param outPath Full resulting filename (ex. /folder1/folder2/result.xps)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
 @return AsposeResponse*/
func (a *PdfApiService) PutPdfInStorageToXps(name string, outPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/convert/xps"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("outPath", parameterToString(outPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Replace document polyline annotation
 @param name The document name.
 @param annotationId The annotation ID.
 @param annotation Annotation.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return PolyLineAnnotationResponse*/
func (a *PdfApiService) PutPolyLineAnnotation(name string, annotationId string, annotation PolyLineAnnotation, localVarOptionals map[string]interface{}) (PolyLineAnnotationResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload PolyLineAnnotationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/polyline/{annotationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &annotation
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Replace document polygon annotation
 @param name The document name.
 @param annotationId The annotation ID.
 @param annotation Annotation.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return PolygonAnnotationResponse*/
func (a *PdfApiService) PutPolygonAnnotation(name string, annotationId string, annotation PolygonAnnotation, localVarOptionals map[string]interface{}) (PolygonAnnotationResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload PolygonAnnotationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/polygon/{annotationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &annotation
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Replace document popup annotation
 @param name The document name.
 @param annotationId The annotation ID.
 @param annotation Annotation.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return PopupAnnotationResponse*/
func (a *PdfApiService) PutPopupAnnotation(name string, annotationId string, annotation PopupAnnotation, localVarOptionals map[string]interface{}) (PopupAnnotationResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload PopupAnnotationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/popup/{annotationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &annotation
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Update privilege document.
 @param name The document name.
 @param privileges Document privileges. DocumentPrivilege
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PutPrivileges(name string, privileges DocumentPrivilege, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/privileges"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &privileges
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Convert PS file (located on storage) to PDF format and upload resulting file to storage. 
 @param name The document name.
 @param srcPath Full source filename (ex. /folder1/folder2/template.ps)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "dstFolder" (string) The destination document folder.
     @param "storage" (string) The document storage.
 @return AsposeResponse*/
func (a *PdfApiService) PutPsInStorageToPdf(name string, srcPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/create/ps"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["dstFolder"], "string", "dstFolder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("srcPath", parameterToString(srcPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["dstFolder"].(string); localVarOk {
		localVarQueryParams.Add("dstFolder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Replace document RadioButton field
 @param name The document name.
 @param fieldName The field name.
 @param field The field.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return RadioButtonFieldResponse*/
func (a *PdfApiService) PutRadioButtonField(name string, fieldName string, field RadioButtonField, localVarOptionals map[string]interface{}) (RadioButtonFieldResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload RadioButtonFieldResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/fields/radiobutton/{fieldName}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fieldName"+"}", fmt.Sprintf("%v", fieldName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &field
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Replace document redaction annotation
 @param name The document name.
 @param annotationId The annotation ID.
 @param annotation Annotation.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
     @param "apply" (bool) Apply redaction immediately after adding.
 @return RedactionAnnotationResponse*/
func (a *PdfApiService) PutRedactionAnnotation(name string, annotationId string, annotation RedactionAnnotation, localVarOptionals map[string]interface{}) (RedactionAnnotationResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload RedactionAnnotationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/redaction/{annotationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["apply"], "bool", "apply"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["apply"].(bool); localVarOk {
		localVarQueryParams.Add("apply", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &annotation
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Replace document image.
 @param name The document name.
 @param imageId The image ID.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "imageFilePath" (string) Path to image file if specified. Request content is used otherwise.
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
     @param "image" (*os.File) Image file.
 @return ImageResponse*/
func (a *PdfApiService) PutReplaceImage(name string, imageId string, localVarOptionals map[string]interface{}) (ImageResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload ImageResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/images/{imageId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageId"+"}", fmt.Sprintf("%v", imageId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["imageFilePath"], "string", "imageFilePath"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["imageFilePath"].(string); localVarOk {
		localVarQueryParams.Add("imageFilePath", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "multipart/form-data",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	var localVarFile (*os.File)
	if localVarTempParam, localVarOk := localVarOptionals["image"].(*os.File); localVarOk {
		localVarFile = localVarTempParam
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Replace document multiple image.
 @param name The document name.
 @param imageIds The image IDs.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "imageFilePath" (string) Path to image file if specified. Request content is used otherwise.
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
     @param "image" (*os.File) Image file.
 @return ImagesResponse*/
func (a *PdfApiService) PutReplaceMultipleImage(name string, imageIds []string, localVarOptionals map[string]interface{}) (ImagesResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload ImagesResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/images/replace"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["imageFilePath"], "string", "imageFilePath"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["imageFilePath"].(string); localVarOk {
		localVarQueryParams.Add("imageFilePath", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "multipart/form-data",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	var localVarFile (*os.File)
	if localVarTempParam, localVarOk := localVarOptionals["image"].(*os.File); localVarOk {
		localVarFile = localVarTempParam
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	// body params
	localVarPostBody = &imageIds
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Replace document screen annotation
 @param name The document name.
 @param annotationId The annotation ID.
 @param annotation Annotation.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return ScreenAnnotationResponse*/
func (a *PdfApiService) PutScreenAnnotation(name string, annotationId string, annotation ScreenAnnotation, localVarOptionals map[string]interface{}) (ScreenAnnotationResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload ScreenAnnotationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/screen/{annotationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &annotation
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Extract document screen annotation content to storage
 @param name The document name.
 @param annotationId The annotation ID.
 @param outFilePath The output file path.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PutScreenAnnotationDataExtract(name string, annotationId string, outFilePath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/screen/{annotationId}/data/extract"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("outFilePath", parameterToString(outFilePath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Create searchable PDF document. Generate OCR layer for images in input PDF document.
 @param name The document name.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
     @param "lang" (string) language for OCR engine. Possible values: eng, ara, bel, ben, bul, ces, dan, deu, ell, fin, fra, heb, hin, ind, isl, ita, jpn, kor, nld, nor, pol, por, ron, rus, spa, swe, tha, tur, ukr, vie, chi_sim, chi_tra or thier combination e.g. eng,rus 
 @return AsposeResponse*/
func (a *PdfApiService) PutSearchableDocument(name string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/ocr"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["lang"], "string", "lang"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["lang"].(string); localVarOk {
		localVarQueryParams.Add("lang", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Add/update document property.
 @param name 
 @param propertyName 
 @param value 
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) 
     @param "folder" (string) 
 @return DocumentPropertyResponse*/
func (a *PdfApiService) PutSetProperty(name string, propertyName string, value string, localVarOptionals map[string]interface{}) (DocumentPropertyResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload DocumentPropertyResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/documentproperties/{propertyName}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"propertyName"+"}", fmt.Sprintf("%v", propertyName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("value", parameterToString(value, ""))
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Replace document signature field.
 @param name The document name.
 @param fieldName The field name.
 @param field The field.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return SignatureFieldResponse*/
func (a *PdfApiService) PutSignatureField(name string, fieldName string, field SignatureField, localVarOptionals map[string]interface{}) (SignatureFieldResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload SignatureFieldResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/fields/signature/{fieldName}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fieldName"+"}", fmt.Sprintf("%v", fieldName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &field
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Replace document sound annotation
 @param name The document name.
 @param annotationId The annotation ID.
 @param annotation Annotation.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return SoundAnnotationResponse*/
func (a *PdfApiService) PutSoundAnnotation(name string, annotationId string, annotation SoundAnnotation, localVarOptionals map[string]interface{}) (SoundAnnotationResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload SoundAnnotationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/sound/{annotationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &annotation
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Extract document sound annotation content to storage
 @param name The document name.
 @param annotationId The annotation ID.
 @param outFilePath The output file path.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PutSoundAnnotationDataExtract(name string, annotationId string, outFilePath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/sound/{annotationId}/data/extract"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("outFilePath", parameterToString(outFilePath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Replace document square annotation
 @param name The document name.
 @param annotationId The annotation ID.
 @param annotation Annotation.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return SquareAnnotationResponse*/
func (a *PdfApiService) PutSquareAnnotation(name string, annotationId string, annotation SquareAnnotation, localVarOptionals map[string]interface{}) (SquareAnnotationResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload SquareAnnotationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/square/{annotationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &annotation
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Replace document squiggly annotation
 @param name The document name.
 @param annotationId The annotation ID.
 @param annotation Annotation.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return SquigglyAnnotationResponse*/
func (a *PdfApiService) PutSquigglyAnnotation(name string, annotationId string, annotation SquigglyAnnotation, localVarOptionals map[string]interface{}) (SquigglyAnnotationResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload SquigglyAnnotationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/squiggly/{annotationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &annotation
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Replace document stamp annotation
 @param name The document name.
 @param annotationId The annotation ID.
 @param annotation Annotation.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return StampAnnotationResponse*/
func (a *PdfApiService) PutStampAnnotation(name string, annotationId string, annotation StampAnnotation, localVarOptionals map[string]interface{}) (StampAnnotationResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload StampAnnotationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/stamp/{annotationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &annotation
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Extract document stamp annotation content to storage
 @param name The document name.
 @param annotationId The annotation ID.
 @param outFilePath The output file path.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PutStampAnnotationDataExtract(name string, annotationId string, outFilePath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/stamp/{annotationId}/data/extract"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("outFilePath", parameterToString(outFilePath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Replace document StrikeOut annotation
 @param name The document name.
 @param annotationId The annotation ID.
 @param annotation Annotation.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return StrikeOutAnnotationResponse*/
func (a *PdfApiService) PutStrikeOutAnnotation(name string, annotationId string, annotation StrikeOutAnnotation, localVarOptionals map[string]interface{}) (StrikeOutAnnotationResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload StrikeOutAnnotationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/strikeout/{annotationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &annotation
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Convert SVG file (located on storage) to PDF format and upload resulting file to storage. 
 @param name The document name.
 @param srcPath Full source filename (ex. /folder1/folder2/template.svg)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "adjustPageSize" (bool) Adjust page size
     @param "height" (float64) Page height
     @param "width" (float64) Page width
     @param "isLandscape" (bool) Is page landscaped
     @param "marginLeft" (float64) Page margin left
     @param "marginBottom" (float64) Page margin bottom
     @param "marginRight" (float64) Page margin right
     @param "marginTop" (float64) Page margin top
     @param "dstFolder" (string) The destination document folder.
     @param "storage" (string) The document storage.
 @return AsposeResponse*/
func (a *PdfApiService) PutSvgInStorageToPdf(name string, srcPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/create/svg"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["adjustPageSize"], "bool", "adjustPageSize"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["height"], "float64", "height"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["width"], "float64", "width"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["isLandscape"], "bool", "isLandscape"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["marginLeft"], "float64", "marginLeft"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["marginBottom"], "float64", "marginBottom"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["marginRight"], "float64", "marginRight"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["marginTop"], "float64", "marginTop"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["dstFolder"], "string", "dstFolder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("srcPath", parameterToString(srcPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["adjustPageSize"].(bool); localVarOk {
		localVarQueryParams.Add("adjustPageSize", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["height"].(float64); localVarOk {
		localVarQueryParams.Add("height", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["width"].(float64); localVarOk {
		localVarQueryParams.Add("width", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["isLandscape"].(bool); localVarOk {
		localVarQueryParams.Add("isLandscape", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["marginLeft"].(float64); localVarOk {
		localVarQueryParams.Add("marginLeft", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["marginBottom"].(float64); localVarOk {
		localVarQueryParams.Add("marginBottom", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["marginRight"].(float64); localVarOk {
		localVarQueryParams.Add("marginRight", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["marginTop"].(float64); localVarOk {
		localVarQueryParams.Add("marginTop", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["dstFolder"].(string); localVarOk {
		localVarQueryParams.Add("dstFolder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Replace document page table.
 @param name The document name.
 @param tableId The table ID.
 @param table The table.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return AsposeResponse*/
func (a *PdfApiService) PutTable(name string, tableId string, table Table, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/tables/{tableId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tableId"+"}", fmt.Sprintf("%v", tableId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &table
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Convert TeX file (located on storage) to PDF format and upload resulting file to storage. 
 @param name The document name.
 @param srcPath Full source filename (ex. /folder1/folder2/template.tex)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "dstFolder" (string) The destination document folder.
     @param "storage" (string) The document storage.
 @return AsposeResponse*/
func (a *PdfApiService) PutTeXInStorageToPdf(name string, srcPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/create/tex"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["dstFolder"], "string", "dstFolder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("srcPath", parameterToString(srcPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["dstFolder"].(string); localVarOk {
		localVarQueryParams.Add("dstFolder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Replace document text annotation
 @param name The document name.
 @param annotationId The annotation ID.
 @param annotation Annotation.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return TextAnnotationResponse*/
func (a *PdfApiService) PutTextAnnotation(name string, annotationId string, annotation TextAnnotation, localVarOptionals map[string]interface{}) (TextAnnotationResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload TextAnnotationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/text/{annotationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &annotation
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Replace document text box field
 @param name The document name.
 @param fieldName The field name.
 @param field The field.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return TextBoxFieldResponse*/
func (a *PdfApiService) PutTextBoxField(name string, fieldName string, field TextBoxField, localVarOptionals map[string]interface{}) (TextBoxFieldResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload TextBoxFieldResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/fields/textbox/{fieldName}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fieldName"+"}", fmt.Sprintf("%v", fieldName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &field
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Replace document underline annotation
 @param name The document name.
 @param annotationId The annotation ID.
 @param annotation Annotation.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return UnderlineAnnotationResponse*/
func (a *PdfApiService) PutUnderlineAnnotation(name string, annotationId string, annotation UnderlineAnnotation, localVarOptionals map[string]interface{}) (UnderlineAnnotationResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload UnderlineAnnotationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/annotations/underline/{annotationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotationId"+"}", fmt.Sprintf("%v", annotationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &annotation
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Update field.
 @param name The document name.
 @param fieldName The name of a field to be updated.
 @param field Field with the field data.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return FieldResponse*/
func (a *PdfApiService) PutUpdateField(name string, fieldName string, field Field, localVarOptionals map[string]interface{}) (FieldResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload FieldResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/fields/{fieldName}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fieldName"+"}", fmt.Sprintf("%v", fieldName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &field
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Update fields.
 @param name The document name.
 @param fields Fields with the fields data.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "folder" (string) The document folder.
 @return FieldsResponse*/
func (a *PdfApiService) PutUpdateFields(name string, fields Fields, localVarOptionals map[string]interface{}) (FieldsResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload FieldsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/fields"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &fields
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Convert web page to PDF format and upload resulting file to storage. 
 @param name The document name.
 @param url Source url
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "height" (float64) Page height
     @param "width" (float64) Page width
     @param "isLandscape" (bool) Is page landscaped
     @param "marginLeft" (float64) Page margin left
     @param "marginBottom" (float64) Page margin bottom
     @param "marginRight" (float64) Page margin right
     @param "marginTop" (float64) Page margin top
     @param "dstFolder" (string) The destination document folder.
     @param "storage" (string) The document storage.
 @return AsposeResponse*/
func (a *PdfApiService) PutWebInStorageToPdf(name string, url string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/create/web"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["height"], "float64", "height"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["width"], "float64", "width"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["isLandscape"], "bool", "isLandscape"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["marginLeft"], "float64", "marginLeft"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["marginBottom"], "float64", "marginBottom"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["marginRight"], "float64", "marginRight"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["marginTop"], "float64", "marginTop"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["dstFolder"], "string", "dstFolder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("url", parameterToString(url, ""))
	if localVarTempParam, localVarOk := localVarOptionals["height"].(float64); localVarOk {
		localVarQueryParams.Add("height", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["width"].(float64); localVarOk {
		localVarQueryParams.Add("width", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["isLandscape"].(bool); localVarOk {
		localVarQueryParams.Add("isLandscape", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["marginLeft"].(float64); localVarOk {
		localVarQueryParams.Add("marginLeft", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["marginBottom"].(float64); localVarOk {
		localVarQueryParams.Add("marginBottom", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["marginRight"].(float64); localVarOk {
		localVarQueryParams.Add("marginRight", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["marginTop"].(float64); localVarOk {
		localVarQueryParams.Add("marginTop", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["dstFolder"].(string); localVarOk {
		localVarQueryParams.Add("dstFolder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Converts PDF document which contains XFA form (in request content) to PDF with AcroForm and uploads resulting file to storage.
 @param outPath Full resulting filename (ex. /folder1/folder2/result.pdf)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storage" (string) The document storage.
     @param "file" (*os.File) A file to be converted.
 @return AsposeResponse*/
func (a *PdfApiService) PutXfaPdfInRequestToAcroForm(outPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/convert/xfatoacroform"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("outPath", parameterToString(outPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "multipart/form-data",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	var localVarFile (*os.File)
	if localVarTempParam, localVarOk := localVarOptionals["file"].(*os.File); localVarOk {
		localVarFile = localVarTempParam
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Converts PDF document which contains XFA form (located on storage) to PDF with AcroForm and uploads resulting file to storage
 @param name The document name.
 @param outPath Full resulting filename (ex. /folder1/folder2/result.pdf)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "folder" (string) The document folder.
     @param "storage" (string) The document storage.
 @return AsposeResponse*/
func (a *PdfApiService) PutXfaPdfInStorageToAcroForm(name string, outPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/convert/xfatoacroform"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["folder"], "string", "folder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("outPath", parameterToString(outPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["folder"].(string); localVarOk {
		localVarQueryParams.Add("folder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Convert XML file (located on storage) to PDF format and upload resulting file to storage. 
 @param name The document name.
 @param srcPath Full source filename (ex. /folder1/folder2/template.xml)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "xslFilePath" (string) Full XSL source filename (ex. /folder1/folder2/template.xsl)
     @param "dstFolder" (string) The destination document folder.
     @param "storage" (string) The document storage.
 @return AsposeResponse*/
func (a *PdfApiService) PutXmlInStorageToPdf(name string, srcPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/create/xml"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["xslFilePath"], "string", "xslFilePath"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["dstFolder"], "string", "dstFolder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("srcPath", parameterToString(srcPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["xslFilePath"].(string); localVarOk {
		localVarQueryParams.Add("xslFilePath", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["dstFolder"].(string); localVarOk {
		localVarQueryParams.Add("dstFolder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Convert XPS file (located on storage) to PDF format and upload resulting file to storage. 
 @param name The document name.
 @param srcPath Full source filename (ex. /folder1/folder2/template.xps)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "dstFolder" (string) The destination document folder.
     @param "storage" (string) The document storage.
 @return AsposeResponse*/
func (a *PdfApiService) PutXpsInStorageToPdf(name string, srcPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/create/xps"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["dstFolder"], "string", "dstFolder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("srcPath", parameterToString(srcPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["dstFolder"].(string); localVarOk {
		localVarQueryParams.Add("dstFolder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Convert XslFo file (located on storage) to PDF format and upload resulting file to storage. 
 @param name The document name.
 @param srcPath Full source filename (ex. /folder1/folder2/template.xpsfo)
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "dstFolder" (string) The destination document folder.
     @param "storage" (string) The document storage.
 @return AsposeResponse*/
func (a *PdfApiService) PutXslFoInStorageToPdf(name string, srcPath string, localVarOptionals map[string]interface{}) (AsposeResponse,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload AsposeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/{name}/create/xslfo"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["dstFolder"], "string", "dstFolder"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["storage"], "string", "storage"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("srcPath", parameterToString(srcPath, ""))
	if localVarTempParam, localVarOk := localVarOptionals["dstFolder"].(string); localVarOk {
		localVarQueryParams.Add("dstFolder", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["storage"].(string); localVarOk {
		localVarQueryParams.Add("storage", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Check if storage exists
 @param storageName Storage name
 @return StorageExist*/
func (a *PdfApiService) StorageExists(storageName string) (StorageExist,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload StorageExist
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/storage/{storageName}/exist"
	localVarPath = strings.Replace(localVarPath, "{"+"storageName"+"}", fmt.Sprintf("%v", storageName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* PdfApiService Upload file
 @param path Path where to upload including filename and extension e.g. /file.ext or /Folder 1/file.ext             If the content is multipart and path does not contains the file name it tries to get them from filename parameter             from Content-Disposition header.             
 @param file File to upload
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "storageName" (string) Storage name
 @return FilesUploadResult*/
func (a *PdfApiService) UploadFile(path string, file *os.File, localVarOptionals map[string]interface{}) (FilesUploadResult,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload FilesUploadResult
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pdf/storage/file/{path}"
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", fmt.Sprintf("%v", path), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _url.Values{}
	localVarFormParams := _url.Values{}

	if err := typeCheckParameter(localVarOptionals["storageName"], "string", "storageName"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["storageName"].(string); localVarOk {
		localVarQueryParams.Add("storageName", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "multipart/form-data",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	var localVarFile (*os.File) = file
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	r, err := a.client.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
    
	if err = deserializeDTO(localVarHttpResponse.Body, &successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

